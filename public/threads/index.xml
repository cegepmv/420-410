<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Threads :: Introduction aux plateformes IdO</title>
    <link>http://localhost:1313/420-410/threads/index.html</link>
    <description>Processus en parallèle</description>
    <generator>Hugo</generator>
    <language>fr-ca</language>
    <lastBuildDate>Sun, 11 Feb 2024 19:56:53 -0500</lastBuildDate>
    <atom:link href="http://localhost:1313/420-410/threads/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Processus en parallèle</title>
      <link>http://localhost:1313/420-410/threads/parallel/index.html</link>
      <pubDate>Sun, 11 Feb 2024 19:56:53 -0500</pubDate>
      <guid>http://localhost:1313/420-410/threads/parallel/index.html</guid>
      <description>Dans les applications connectées, il est fréquent qu’un même programme doive gérer plusieurs processus simultanément. Cela peut poser des problèmes lorsqu’une tâche monopolise le processeur et que pendant ce temps, d’autres processus attendent leur tour.&#xA;Dans un programme ordinaire, les instructions sont exécutées en séquence:&#xA;long double pi; pi = calculerPiALaMillioniemeDecimale() printf(&#34;SVP Patientez&#34;); Dans cet exemple, le message “SVP Patientez” est assez inutile car l’instruction printf() ne s’exécutera pas tant que la fonction de la ligne précédente ne sera pas terminée.</description>
    </item>
  </channel>
</rss>