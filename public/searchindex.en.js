var relearn_searchindex = [
  {
    "breadcrumb": "",
    "content": "Configuration du RaspberryPi pour le cours.\nConnexion Développement en C Logiciels requis",
    "description": "Configuration du RaspberryPi pour le cours.\nConnexion Développement en C Logiciels requis",
    "tags": [],
    "title": "Préparation",
    "uri": "/420-410/pr%C3%A9paration/index.html"
  },
  {
    "breadcrumb": "Préparation",
    "content": "Dans cette section nous verrons comment accéder au RaspberryPi à distance avec VSCode.\nActiver le service ssh Le service SSH doit s’exécuter sur le Pi pour que la connexion de VSCode soit possible. Aussi, il est utilise de faire en sorte qu’il démarre automatiquement chaque fois que la Pi est allumé. Pour ce faire, lancez les deux commandes suivantes:\nsudo systemctl enable ssh sudo systemctl start ssh Changer le nom d’hôte Il est possible de se connecter sur le Pi en utilisant son adresse IP, mais il est souvent plus pratique d’utiliser un nom pour y référer. Pour y arriver il faut modifier deux fichiers.\nDans /etc/hostname, écrivez le nom que vous voulez lui donner:\nbork Dans /etc/hosts, remplacez “raspberrypi” par le nouveau nom:\n127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback ff02::1 ip6-allnodes ff02::2 ip6-allrouters 127.0.1.1 bork Redémarrez ensuite votre Pi.\nÀ cette étape, il devrait être accessible sur le réseau par son nom suivi du suffixe .local. Testez avec la comande ping:\nping bork.local Connexion par VSCode Dans le coin inférieur gauche de VSCode, cliquez sur l’élément suivant:\nChoisissez ensuite l’option Connect to Host..., puis entrez la commande de connexion SSH (vous pouvez ici utiliser le nom de votre Pi ou son adresse IP):\nRépondez ensuite aux questions (mot de passe etc.). Si tout se passe bien, vous devriez ensuite être connecté.",
    "description": "Dans cette section nous verrons comment accéder au RaspberryPi à distance avec VSCode.\nActiver le service ssh Le service SSH doit s’exécuter sur le Pi pour que la connexion de VSCode soit possible. Aussi, il est utilise de faire en sorte qu’il démarre automatiquement chaque fois que la Pi est allumé. Pour ce faire, lancez les deux commandes suivantes:\nsudo systemctl enable ssh sudo systemctl start ssh Changer le nom d’hôte Il est possible de se connecter sur le Pi en utilisant son adresse IP, mais il est souvent plus pratique d’utiliser un nom pour y référer. Pour y arriver il faut modifier deux fichiers.",
    "tags": [],
    "title": "Connexion",
    "uri": "/420-410/pr%C3%A9paration/connexion/index.html"
  },
  {
    "breadcrumb": "Préparation",
    "content": "Pour programmer en Python sur un RaspberryPi, il est essentiel d’installer quelques logiciels et modules.\nOutils de développement Les programmes et libraires requis sont les suivants:\npython3 ; Les modules venv et pigpio de pip. Normalement, python3 devrait déjà être installé dans RaspberryPi OS. Toutefois, si ce n’est pas le cas, il est possible de le faire manuellement en installant le paquet python3 avec la commande suivante:\nsudo apt update sudo apt install python3 Environnement virtuel Python (venv) Le module Python venv permet de créer des “environnements virtuels” légers, portables et isolés du système global. Chaque environnement virtuel a son propre binaire Python (qui correspond à la version du binaire qui a été utilisée pour créer cet environnement) et peut avoir sa propre liste de paquets Python installée.\nLes environnements virtuels permettent d’éviter d’avoir à installer les paquets Python sur tout le système. Il permettent aussi de créer un fichier de configuration contenant la liste complète des dépendances/modules de notre programme, ce qui facilite grandement son exportation sur une autre machine.\nCréation d’un environnement virtuel La création d’un environnement virtuel se fait en exécutant la commande venv, suivie du chemin du répertoire qui contiendra la configuration de l’environnement :\npython3 -m venv /chemin/vers/le/dossier/de/lenvironment/virtuel Pour rentrer dans l’environnement virtuel, il suffit de lancer la commande suivante :\nsource /chemin/vers/le/dossier/de/lenvironment/virtuel/bin/activate Conseils Créez le répertoire de l’environnement virtuel à l’intérieur du répertoire de votre programme.\nPour vérifier que nous sommes bel et bien à l’intérieur de l’environnement virtuel, son nom devrait apparaître sur la ligne de commande (entre parenthèses) :\nLorsque l’environnement virtuel est actif, pip installe les paquets dans l’environnement, ce qui n’affecte en rien l’installation de base de Python (celle du système global).\nPour “sauvegarder” la liste des modules installés, il faut utiliser la commande pip freeze :\npip freeze \u003e requirements.txt Cette commande redirige la liste des modules et les dépendances installées dans un fichier requirements.txt :\nAttention À chaque fois que vous installez un nouveau module dans votre environnement virtuel, n’oubliez pas de relancer la commande pip freeze \u003e requirements.txt pour mettre à jour la liste !\nPour sortir de l’environnement, il suffit de lancer la commande deactivate (vous remarquerez que le nom de l’environnement virtuel disparait de la ligne de commande) :\nSi vous désirez exporter votre code sur une autre machine (par exemple, sur un autre Raspberry PI), il vous suffira de copier votre code (et le fichier requirements.txt), créer un nouvel environnement virtuel, entrer dans l’environnement, puis lancer la commande suivante :\npip install -r requirements.txt Cette commande installera la liste des paquets et et les dépendances du fichier requirements.txt.\nModule GPIO Le RaspberryPi est équipé de 40 broches GPIO utilisées pour communiquer avec différents périphériques: senseurs, actuateurs, moteurs, LED, etc.\n(source: https://pinout.xyz/)\nPour communiquer avec cette interface à partir d’un programme en Python on utilise le module pigpio.\nLa documentation de pigpio est ici: https://abyz.me.uk/rpi/pigpio/python.html\nNormalement il est déjà disponible sur Raspberry Pi OS, mais au besoin on peut aussi l’installer à partir des dépôts de comme suit:\nsudo apt update sudo apt install pigpio Pour exécuter le service et s’assurer qu’il le sera à chaque démarrage du Pi, vous devez entrer les commandes suivantes:\nsudo systemctl start pigpiod sudo systemctl enable pigpiod Dans le programme suivant un courant de 3.3V est envoyé durant 1 seconde sur la broche 11 du Pi (qui correspond à l’identifiant GPIO 17 dans pigpio):\nimport pigpio import time # Initialisation pi = pigpio.pi() # Définir le mode du GPIO 17 LED = 17 pi.set_mode(LED, pigpio.OUTPUT) try: # Allumer 1 seconde pi.write(LED, 1) time.sleep(1) # Éteindre pi.write(LED, 0) finally: pi.stop()",
    "description": "Pour programmer en Python sur un RaspberryPi, il est essentiel d’installer quelques logiciels et modules.\nOutils de développement Les programmes et libraires requis sont les suivants:\npython3 ; Les modules venv et pigpio de pip. Normalement, python3 devrait déjà être installé dans RaspberryPi OS. Toutefois, si ce n’est pas le cas, il est possible de le faire manuellement en installant le paquet python3 avec la commande suivante:\nsudo apt update sudo apt install python3 Environnement virtuel Python (venv) Le module Python venv permet de créer des “environnements virtuels” légers, portables et isolés du système global. Chaque environnement virtuel a son propre binaire Python (qui correspond à la version du binaire qui a été utilisée pour créer cet environnement) et peut avoir sa propre liste de paquets Python installée.",
    "tags": [],
    "title": "Logiciels requis",
    "uri": "/420-410/pr%C3%A9paration/logiciels/index.html"
  },
  {
    "breadcrumb": "Le langage C",
    "content": "Affichage int printf() Cette fonction affiche des informations sur la sortie standard (par défaut, l’écran). Avec une seule chaîne de caractères comme argument, elle l’affiche telle quelle:\nprintf(\"Bonjour tout le monde\"); La fonction retourne un entier qui représente le nombre de caractères affichés; une valeur négative signifie qu’une erreur est survenue lors de l’exécution.\nIl est possible d’insérer des valeurs ou des variables dans la chaîne de caractères affichée et de spécifier leur format. Par exemple:\nprintf(\"Le nombre %i est affiché\\n\",25); Dans cet exemple le 2e paramètre de la fonction est la valeur littérale 25. Le spécifieur %i signifie que cette valeur doit être interprétée puis affichée comme un nombre entier. On le met à l’endroit où la valeur doit être insérée dans la chaîne de caractères.\nIl existe plusieurs types de spécifieurs selon le type de données à afficher. Par exemple, un nombre sera représenté en hexadécimal si on utilise %x, en nombre décimal avec %f, etc. Le tableau suivant énumère les principaux:\nSYMBOLE TYPE INTERPRÉTATION %d ou %i int entier (signé) %u int entier naturel (non-signé) %o int entier exprimé en octal %x int entier exprimé en hexadécimal %c int caractère %f double rationnel en notation décimale %e double rationnel en notation scientifique %s char* chaîne de caractères Cette valeur peut aussi être définie dans une variable. Dans l’exemple suivant on affiche la valeur d’une variable selon différents formats:\nint i = 256; printf(\"Le nombre %i est affiché comme entier\\n\",i); printf(\"Le nombre %x est affiché en hexadécimal\\n\",i); printf(\"Le nombre %f est affiché en décimal\\n\",(float)i/3); Que se passe-t-il si on omet (float) au 3e appel de printf() ?\nSaisie int scanf() Cette fonction prend une chaîne de caractères saisie sur l’entrée standard (par défaut, la ligne de commande) et stocke sons contenu dans une ou plusieurs variables.\nLa valeur retournée désigne le nombre de valeurs qui ont été traitées dans la chaîne saisie.\nscanf() prend comme premier argument une chaîne de caractères composée des spécifieurs, puis des variables qui correspondent à ceux-ci. Par exemple, dans l’instruction suivante on lit un nombre entier et on le stocke dans la variable nombre:\nscanf(\"%d\",\u0026nombre); Les variables dans lesquelles les valeurs seront stockées doivent être déclarées au préalable. Le code suivant affichera donc un nombre entré par l’utilisateur:\nint main() { int i; printf(\"Entrez un nombre: \"); scanf(\"%d\",\u0026i); printf(\"Vous avez entré le nombre %d\\n\",i); return 0; } Pour saisir un caractère, il suffit de déclarer et ensuite d’afficher notre variable en conséquence:\nint main() { char i; printf(\"Entrez un caractère: \"); scanf(\"%c\",\u0026i); printf(\"Vous avez entré le caractère %c\\n\",i); printf(\"La valeur numérique de %c est %d\\n\",i,i); return 0; } Remarquez que puisque char est en réalité représenté comme un entier, il est possible de l’afficher comme tel.\nPour saisir des chaînes de caractères, la variable doit être une liste (“array”) de char, et on doit lui définir une taille fixe.\nint main() { char chaine[10]; printf(\"Entrez un mot: \"); scanf(\"%s\",chaine); printf(\"Vous avez entré le mot %s\\n\",chaine); return 0; } Attention, ici la variable chaine dans la fonction scanf() n’est pas précédée de \u0026.\nExercices 1 Créez un programme nommé cours2.c qui permet d’afficher la phrase classique Hello world.\n2 Modifier le Makefile suivant afin que la commande make (sans argument) compile ce fichier vers cours2 et exécute le programme.\nall: cours2: cours2.c # Commande de compilation ./cours2 3 Faites un programme pour prendre comme entrée le nom d’un utilisateur et vérifier si le nom entré est “Jean”. Affichez “Bienvenue” si c’est le cas, sinon affichez “Allez-vous en”.\nLa fonction strcmp() vous sera utile ici…\n4 Voyons maintenant comment utiliser les PINs du RaspberryPi\nsudo apt update sudo apt upgrade sudo apt install pigpio sudo systemctl start pigpiod sudo systemctl enable pigpiod Il faut compiler comme suit (En ajoutant le fichier librairie lpigpio) :\ngcc -o cours2 cours2.c -lpigpio #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003cpigpio.h\u003e #define PIN_NUMBER 18 int main() { // Initialiser if (gpioInitialise() \u003c 0) { fprintf(stderr, \"Failed to initialize pigpio\\n\"); return 1; } // Définir en mode output gpioSetMode(PIN_NUMBER, PI_OUTPUT); while (1) { // Allumer 1 s gpioWrite(PIN_NUMBER, 1); usleep(1000000); // Éteindre 1 s gpioWrite(PIN_NUMBER, 0); usleep(1000000); } // Terminate the pigpio library gpioTerminate(); return 0; } S’il y a des problèmes avec l’initialisation de pigpio, essayer:\nsudo killall pigpiod sudo rm -f /var/run/pigpio.pid Car il se peut qu’il y ait des processus qui trainent.\n5 Faites un programme qui allume une LED lorsque vous appuyez sur un bouton (une LED et un bouton du kit KeyStudio).\n6 Faites un programme qui allume ou éteint une LED selon ce qui est saisi à la ligne de commande:\nprintf(\"#########################################\\n\"); printf(\"Choisissez l'une des options suivantes:\\n\"); printf(\"#########################################\\n\"); printf(\" allume - Pour allumer la LED\\n\"); printf(\" ferme - Pour fermer la LED\\n\"); printf(\" quitter - Pour quitter\\n\");",
    "description": "Affichage int printf() Cette fonction affiche des informations sur la sortie standard (par défaut, l’écran). Avec une seule chaîne de caractères comme argument, elle l’affiche telle quelle:\nprintf(\"Bonjour tout le monde\"); La fonction retourne un entier qui représente le nombre de caractères affichés; une valeur négative signifie qu’une erreur est survenue lors de l’exécution.\nIl est possible d’insérer des valeurs ou des variables dans la chaîne de caractères affichée et de spécifier leur format. Par exemple:",
    "tags": [],
    "title": "Affichage et saisie",
    "uri": "/420-410/c/affichagesaisie/index.html"
  },
  {
    "breadcrumb": "Préparation",
    "content": "Dans cette section nous verrons les outils courants pour développer des programmes en C sur RaspberryPi.\nCompilation La compilation d’un programme est la traduction du code source en code machine. Le code machine se compose de différentes instructions qui peuvent varier selon le CPU ou le système d’exploitation; c’est pourquoi le fichier exécutable d’un programme pour Windows ne pourra pas être exécuté sur un RaspberryPi (par exemple).\nLorsqu’on compile un programme, le code source est analysé, optimisé et les instructions (qui peuvent se trouver dans différents fichiers) sont regroupées en un exécutable unique.\nLe programme suivant affiche “Bonjour le monde” à l’écran:\nhello.c\n#include \u003cstdio.h\u003e int main() { printf(\"Bonjour le monde!\\n\"); } La fonction printf() sert à afficher une chaîne de caractère.\nL’instruction #include importe les définitions de fonctions de la librairie stdio (contenues dans le fichier stdio.h), dont la fonction printf() fait partie.\nPour compiler ce programme, on utilisera le compilateur gcc (GNU C Compiler) cpmme suit:\ngcc hello.c L’exécutable créé par cette compilation sera sauvegardé dans un fichier nommé a.out. Pour changer le nom de ce fichier, on utilise l’option -o, comme dans l’exemple suivant où l’exécutable portera le nom hello:\ngcc -o hello hello.c Info Les options du programme gcc sont nombreuses: -o spécifie le nom de l’exécutable, -l permet de lier le programme avec une librairie externe, -v affiche des messages, etc. La documentation officielle est ici: https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html\nMakefile La commande gcc comprend de nombreuses options qui peuvent générer des exécutables différents, et parfois la compilation d’un programme se fait en plusieurs étapes où chacune de ses parties sera compilées séparément.\nSupposons par exemple qu’on a 2 versions du programme à compiler: une version de débogage avec tous les messages de compilation, et une version sans messages avec l’exécutable renommé. Il y aurait donc 2 commandes de compilation:\ngcc hello.c -g -v gcc hello.c -o hello Plutôt que de lancer chacune séparément, on peut avoir un Makefile avec deux cibles (nommées par exemple release et debug)\nall: release debug: hello.c gcc -g -v hello.c release: hello.c gcc -o hello hello.c clean: rm -f hello a.out CIBLE: DÉPENDANCES COMMANDE COMMANDE ... Ainsi make debug compilera la version de débogage, make release compilera la version finale, etc.\nLa cible all définit la cible par défaut si on lance make sans arguments.\nIl est recommandé de mettre chaque projet dans un répertoire différent afin que chacun d’eux puisse avoir son propre Makefile.\nFichiers de programme Afin de faciliter l’orgaisation des fichiers de code source et de favoriser leur réutilisation, il est utile de séparer un programme dans plusieurs fichiers:\nsalutation.c\n#include \u003cstdio.h\u003e void saluerFr() { printf(\"Bonjour le monde!\\n\"); } void saluerEn() { printf(\"Hello World!\\n\"); } hello.c\n#include \u003cstdio.h\u003e void saluerFr(); void saluerEn(); int main() { saluerFr(); saluerEn(); return 0; } Dans les exemples ci-dessus, les fonctions saluerFr() et saluerEn() ne sont pas définies dans le fichier hello.c; cependant au moment de la compilation un lien sera fait avec le fichier qui les contient (salutations.c). Mais il faut quand même les déclarer dans hello.c pour pouvoir les utiliser: c’est ce que l’on fait aux lignes 3-4 du programme.\nPour compiler le programme, il s’agit d’ajouter le nouveau fichier, qui contient les deux fonctions, aux arguments de gcc lorsqu’on lance la compilation:\ngcc hello.c salutations.c -o hello Le Makefile doit aussi être modifié en conséquence:\nall: release debug: hello.c gcc -v hello.c salutations.c release: hello.c gcc -o hello hello.c salutations.c clean: rm -f hello a.out Entêtes (headers) Lorsqu’on construit un programme il est facile de le faire de façon désorganisée. Ceci rend le code et la structure du programme difficiles à comprendre, et donc difficiles à déboguer et améliorer.\nUtiliser une nomenclature pour les fonctions et les variables, indenter le code clairement et insérer des commentaires sont des exmples de mesures qui rendent le code plus facile à maintenir. Une autre bonne pratique en C consiste à séparer les déclarations du code principal et les mettre dans des fichiers séparés avec l’extension .h (pour “headers”).\nLe programme hello serait donc constitué des fichiers suivants:\nhello.c: Ne contient plus les déclarations de fonctions; mais contient une instruction #include qui permet au compilateur de lier les déclarations des fonctions au programme principal.\n#include \u003cstdio.h\u003e #include \"salutations.h\" int main() { saluerFr(); saluerEn(); return 0; } salutations.c: Inchangé\n#include \u003cstdio.h\u003e void saluerFr() { printf(\"Bonjour le monde!\\n\"); } void saluerEn() { printf(\"Hello World!\\n\"); } salutations.h: Déclarations de fonctions\nvoid saluerFr(); void saluerEn(); Débogage Un programme compilé contient des instructions en langage machine: ces instructions ne sont pas identifées de la même manière dans un fichier exécutable qu’elles le sont dans le code source - si votre code contient une variable nommée luminosite, on ne retrouvera pas cette chaîne de caractères dans l’exécutable.\nLorsqu’on débogue un programme compilé, le débogueur doit être en mesure de faire le lien entre les éléments dans l’exécutable et leurs correspondants dans le code source. Il faut lui donner la liste des noms de variables, de fonctions, etc. qu’il doit associer au programme compilé. On nomme cette liste la “table des symboles”, et on l’inclut au programme exécutable en ajoutant l’option -g lors de la compilation.\nLa première chose à faire pour déboguer des programmes en C est donc de les compiler en incluant les informations de débogage, comme suit:\ngcc -g -o programme programme.c VSCode Pour déboguer un programme en C dans VSCode, il faut commencer par installer l’extension C/C++ au moment où VSCode est connecté sur le Pi:\nSélectionnez ensuite le fichier source à déboguer puis cliquez sur le bouton Run and Debug.\nÀ cette étape il faut définir une configuration de débogage. Dans VSCode, elles sont définies dans des fichiers JSON. Vous pouvez en créer une vous-même mais il est plus simple d’en choisir une parmi les modèles prédéfinis: cliquez sur Show all automatic debug configurations. Ceci fait apparaître le menu des débogueurs disponibles.\nSélectionnez C++ (GDB/LLDB), puis Default Configuration, et ensuite cliquez sur les paramètres de (gdb) Launch pour modifier sa configuration:\nNous allons indiquer à VSCode que le programme à déboguer est nommé a.out dans le répertoire courant:\nIl faut donc s’assurer que la commande pour la version debug du programme soit conforme dans le Makefile (c’est-à-dire qu’elle ait l’option -g et qu’elle ne renomme pas le fichier compilé), comme suit:\ndebug: test.c gcc -g test.c Lancez ensuite make debug, puis enfin vous pourrez lancer le débogage dans VSCode:\npigpio L’appel de la fonction gpioInitialise() nécessite les permissions root, donc un programme qui appelle cette fonction doit être précédé de sudo. Comme on ne peut pas spécifier à launch.json d’utiliser sudo, la solution consiste à se connecter sur le Pi avec VSCode en tant que root.\nPour ce faire, il faut modifier le fichier /etc/ssh/sshd_config pour qu’il contienne la ligne PermitRootLogin yes. Redémarrez ensuite le service ssh.",
    "description": "Dans cette section nous verrons les outils courants pour développer des programmes en C sur RaspberryPi.\nCompilation La compilation d’un programme est la traduction du code source en code machine. Le code machine se compose de différentes instructions qui peuvent varier selon le CPU ou le système d’exploitation; c’est pourquoi le fichier exécutable d’un programme pour Windows ne pourra pas être exécuté sur un RaspberryPi (par exemple).\nLorsqu’on compile un programme, le code source est analysé, optimisé et les instructions (qui peuvent se trouver dans différents fichiers) sont regroupées en un exécutable unique.",
    "tags": [],
    "title": "Développement en C",
    "uri": "/420-410/pr%C3%A9paration/develop/index.html"
  },
  {
    "breadcrumb": "Le langage C",
    "content": "Variables et mémoire Lorsqu’on déclare une variable dans un programme, elle est stockée à un endroit précis de la mémoire. Cet endroit a une adresse, notée en hexadécimal, et c’est l’adresse qui se trouve au début des données contenues dans la variable qui est utilisée.\nDans l’exemple suivant, la variable nommée mot contient la chaîne de caractères “abcd” et est à l’adresse 0x77fe00:\nL’espace occupé par une variable dans la mémoire dépend de ce qu’elle contient: dans l’exemple, plus la chaîne de caractères contenue dans mot est longue, plus l’espace occupé par la variable sera grand. Mais le type d’une variable a aussi un effet sur l’espace qu’elle occupe.\nTypes Dans le langage C, les variables peuvent avoir les types char, int, long, float et double. Ces types permettent de stocker des valeurs numériques de tailles différentes car le nombre d’octets qu’ils utilisent pour stocker les variables sont différents. Le tableau suivant compare les types pour les nombres entiers:\nType Nombre d’octets Valeurs possibles char 1 256 (2⁸) int 4 4,3 milliards (2³²) long 8 plein (2⁶⁴) Les types peuvent être signés, c’est-à-dire qu’ils acceptent les valeurs négatives, ou non-signés (soit 0 ou une valeur positive). Dans les deux cas, le nombre de valeurs différentes possibles demeure le même: par exemple, une variable de type int non-signé peut avoir une valeur de 0 à 4 294 967 295; un int signé peut avoir une valeur de -2 147 483 648 à 2 147 483 647.\nPar défaut, les variables sont toujours signées à moins d’ajouter le mot-clé unsigned devant leur type au moment de leur déclaration.\nLa mémoire peut ainsi contenir des variables de divers types occupant des blocs de taille différentes:\nDans cet exemple:\nUne variable de type long est à l’adresse 0x77fe00 et a la valeur 5655434; Une variable de type char est à l’adresse 0x77fe08 et a la valeur 119, ce qui correspond à “w” selon le standard ASCII; Une variable de type int est à l’adresse 0x77fe09 et a la valeur 23112. Exercices Quelle est la valeur numérique maximale qu’on peut donner à une variable de type char signée? Quelle est la valeur minimale qu’on peut donner à une variable long non signée? Quels types peut-on donner à une variable si on veut qu’elle contienne le nombre 0xb2d05e00? Réponses 127 0 unsigned int, long Pointeurs Un pointeur est une variable dont le comportement est différent des variables ordinaires.\nNormalement lorsqu’on utilise une variable, ce qui nous intéresse est sa valeur:\nint main() { int a = 10; printf(\"%d\\n\",a); printf(\"%d\\n\",a*3); for (int i=0;i\u003ca;i++){ // Ce code sera répété 'a' fois } return 0; } Dans cet exemple, on donne à la variable a la valeur 10, et par la suite chaque fois qu’on réfère à a dans le programme c’est en fait sa valeur (10) qui est utilisée.\nDans certains cas par contre, ce qui serait utile au programme serait de connaitre l’adresse d’une variable. Dans cette situation, il faut déclarer la variable différemment:\nint main() { int a = 10; int *p = \u0026a; printf(\"%d\\n\",*p); //Affiche 10 (ce qu'il y a à l'adresse de 'a') printf(\"%p\\n\",p); //Affiche 0x7fff206ab37c (l'adresse de 'a') printf(\"%p\\n\",\u0026a); //Affiche 0x7fff206ab37c (l'adresse de 'a') return 0; } Dans cet exemple, \u0026a désigne l’adresse de a (pas sa valeur). Si on veut conserver cette adresse dans une autre variable, il faut que cette autre variable soit déclarée comme un pointeur. Pour ce faire, on la précède par * à sa déclaration; et attention, un pointeur doit avoir le même type que la variable qu’il pointe.\nUn pointeur est simplement une variable dont la valeur est une adresse mémoire, ce qui lui permet de pointer sur une valeur sans vraiment la contenir.\nDans l’exemple, on utilise le pointeur de deux façons:\np, qui affcihe l’adresse de la variable a; *p, qui affiche la valeur à l’adresse de la variable ‘a’ L’exemple suivant utilise les pointeurs pour montrer que l’adresse d’une variable ne change pas lorsque sa valeur change:\nint main() { int a = 10; int *p = \u0026a; printf(\"valeur %d\\n\",*p); printf(\"adresse %p\\n\",p); a = 30; printf(\"valeur %d\\n\",*p); printf(\"adresse %p\\n\",p); return 0; } Exercices Attention, pour afficher l’adresse d’un pointeur avec printf()on doit utiliser le spécifieur %p.\nFaites un programme qui déclare la variable n de type long dont la valeur est 1000, puis affichez l’adresse de la variable et sa valeur à l’aide d’un pointeur. Faites un programme qui déclare (sans lui donner de valeur) une variable int nommée i. Affichez ensuite son adresse et sa valeur à l’aide d’un pointeur. Faites un programme qui déclare (sans lui donner de valeur) un pointeur int nommé p. Affichez ensuite son adresse et sa valeur. int *p; print p (nil) Déréférencement Comme on l’a vu plus haut, le pointeur donne accès à deux choses:\nL’adresse d’une information en mémoire L’information elle-même Comme un pointeur est à la base une façon de stocker des adresses, lorsqu’on affiche un pointeur on verra une adresse:\nint *pointeur = \u0026a; printf(\"valeur %p\\n\",pointeur); En utilisant l’opérateur *, le pointeur va à l’adresse qu’il contient lire la valeur:\nint *pointeur = \u0026a; printf(\"valeur %p\\n\",*pointeur); On appelle ce * “opérateur de déréférencement”.\nPuisqu’un pointeur déréférencé donne accès à la valeur, il est possible de changer celle-ci sans passer par la variable d’origine:\nint main() { int a = 10; int *p = \u0026a; printf(\"valeur %d\\n\",a); *p = 30; printf(\"valeur %d\\n\",a); return 0; } Exercices Dans le programme suivant: int main() { int a = 10; int b = a; return 0; } Les variables a et b ont-elles la meme adresse? Prouvez-votre réponse en affichant ces adresses avec des pointeurs.\nCompléter le code suivant pour multiplier la valeur de a par 10 sans utiliser la variable a elle-même. int main() { int a = 10; int *p = \u0026a; //Votre code ici printf(\"valeur %d\\n\",a); return 0; } Déplacement des pointeurs Les pointeurs sont souvent utilisés comme des marque-pages, c’est-à-dire qu’ils permettent de conserver à quelle position le programme se trouve dans une structure de données qu’il utilise.\nPuisqu’un pointeur contient une adresse mémoire, changer sa valeur équivaut à le déplacer dans l’espace-mémoire. Par exemple, avec une variable de type int, l’opérateur ++ incrémente sa valeur de 1. Dans le cas d’un pointeur, le même opérateur déplace le pointeur de 1:\nint main() { char a; char *p = \u0026a; for (int i=0;i\u003c4;i++) { p++; printf(\"adresse %p\\n\",p); } return 0; } Comme le type char a une taille de 1 octet, la boucle dans ce programme incrémente le pointeur de 1 octet à chaque itération; c’est pourquoi les valeurs affichées sont successives. Mais attention, l’incrémentation dépend du type du pointeur. En effet pour un pointeur de type int, le déplacement sera de 4 octets à la fois; pour long, de 8 octets.\nLancez le programme en changeant le type de a et *p en int, vous verrez que les adresses affichées ont des intervalles de 4 octets.\nIl faut être prudent lorsqu’on déplace un pointeur de cette manière: le langage C ne nous prévient pas lorsque le pointeur est dans une zone de mémoire non-initialisée. En effet, nous avons vu plus haut qu’on peut déréférencer un pointeur pour changer la valeur à l’adresse qu’il contient, mais ceci n’est possible que lorsque l’adresse contient effectivemnt une valeur.\nDans l’exemple suivant, on déréférence un pointeur pour changer la valeur à l’adresse qu’il contient, mais on voit que cela cause une erreur lorsque le pointeur ne pointe sur aucune valeur:\nint main() { int a; int *p = \u0026a; printf(\"valeur %d\\n\",*p); printf(\"adresse %p\\n\",p); *p = 433; printf(\"nouvelle valeur %d\\n\",*p); p++; printf(\"nouvelle adresse %p\\n\",p); *p = 261; printf(\"nouvelle valeur %d\\n\",*p); //Erreur return 0; } Ceci survient car la nouvelle adresse (où on essaie d’insérer 261) n’a jamais été initialisée comme int. Elle contient peut-être des données de types différents (donc des blocs de mémoire de taille différente), ce qui cause un erreur de segmentation.\nPointeurs et listes On utilise souvent les pointeurs pour parcourir les tableaux. Dans l’exemple suivant, le tableau liste contient une séquence d’entiers, chacun occupant des blocs de mémoire contigus de 4 octets chacuns. Déplacer un pointeur dans cette liste permet donc d’accéder à chacun de ses éléments:\nint main() { int liste[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int *p = \u0026liste[0]; for (int i=0;i\u003c10;i++) { printf(\"%d,\",*p); p++; } } Dans ce programme, on déclare un tableau nommé liste. Ce tableau est de type int, ce qui signifie qu’il se compose d’une séquence de blocs mémoire de 4 octets (où chaque bloc est une donnée de type int).\nOn place ensuite le pointeur au début du tableau en lui donnant l’adresse du premier élément, \u0026liste[0]. L’incrémentation du pointeur sur les blocs de mémoire permet ainsi de parcourir le tableau.\nSi on déplace le pointeur à des adresses plus loin que le dernier int de la séquence, par exemple avec une boucle for (int i=0;i\u003c100;i++), lire les valeurs à ces adresses ne provoquera pas l’erreur de Segmentation fault vue plus haut mais les données ne sont pas significatives. Essayez!\nExercices Modifier le programme de l’exemple précédent pour afficher les nombres 10, 8, 6, 4, 2 en utilisant uniquement le déplacement du pointeur. Affichez chaque lettre du mot ‘bonjour’ en déplacant un pointeur. Rappelez-vous: un mot est en fait un tableau de caractères. Complétez le programme suivant qui demande deux nombres à l’utilisateur et utilise les pointeurs pour les additionner et afficher le résultat: #include \u003cstdio.h\u003e int main() { int i,j; // Votre code ici printf(\"La somme %d\\n\",*pi+*pj); return 0; } Faites un tableau qui contient 6 nombres entiers et utilisez un pointeur pour vous déplacer dans le tableau et calculer la somme de ses éléments. Pour les variables suivantes: int N[] = {51,21,-9,10,18,-5,5}; int *p; p = N; Trouvez la valeur de:\n*p+3 *(p+3) p+3 (trouvez un équivalent avec N) \u0026N[5]-3 (trouvez un équivalent avec p) *(p+(*p-50)) Faites un programme pour mettre en ordre dans le tableau R tous les éléments de T1 et T2. À la fin, R = {3,7,10,12,12,34,39,41,59,61}. int main() { int T1[] = {10,12,34,39,61}; int T2[] = {3,7,12,41,59}; int R[10]; int *p1; int *p2; // Votre code ici return 0; }",
    "description": "Variables et mémoire Lorsqu’on déclare une variable dans un programme, elle est stockée à un endroit précis de la mémoire. Cet endroit a une adresse, notée en hexadécimal, et c’est l’adresse qui se trouve au début des données contenues dans la variable qui est utilisée.\nDans l’exemple suivant, la variable nommée mot contient la chaîne de caractères “abcd” et est à l’adresse 0x77fe00:",
    "tags": [],
    "title": "Pointeurs",
    "uri": "/420-410/c/pointeurs/index.html"
  },
  {
    "breadcrumb": "Le langage C",
    "content": "Dans cette section on verra comment lire et écrire dans les fichiers, passer des arguments à un programme et gérer la mémoire avec malloc(), realloc() et free().\nLecture et écriture dans des fichiers Lien vers w3school pour les fichiers en C, dont les notes sont très fortement inspirée\nÉcriture Inclusion de la bibliothèque standard C : Assurez-vous d’inclure la bibliothèque standard C en ajoutant la directive #include \u003cstdio.h\u003e au début de votre programme.\n#include \u003cstdio.h\u003e Ouverture et/ou création d’un fichier : Utilisez la fonction fopen() pour ouvrir un fichier. La fonction prend deux paramètres : le nom du fichier et le mode d’ouverture (lecture, écriture, etc.).\nFILE *fichier; fichier = fopen(\"nom_du_fichier.txt\", \"w\"); // \"w\" pour écriture, \"r\" pour lecture Assurez-vous que fichier n’est pas NULL, ce qui indiquerait une ouverture de fichier infructueuse.\nif (fichier == NULL) { printf(\"Erreur lors de l'ouverture du fichier.\\n\"); return 1; } Écriture dans un fichier Utilisez la fonction fprintf() ou fputc() pour écrire dans le fichier.\nfprintf(fichier, \"Bonjour, monde !\\n\"); // ou fputc('A', fichier); Fermeture du fichier Assurez-vous de fermer le fichier après avoir terminé les opérations. Utilisez la fonction fclose().\nfclose(fichier); Voici un exemple complet :\n#include \u003cstdio.h\u003e int main() { FILE *fichier; fichier = fopen(\"mon_fichier.txt\", \"w\"); if (fichier == NULL) { printf(\"Erreur lors de l'ouverture du fichier.\\n\"); return 1; } fprintf(fichier, \"Bonjour, monde !\\n\"); fclose(fichier); return 0; } Cet exemple crée un fichier nommé “mon_fichier.txt” et y écrit la chaîne de caractères “Bonjour, monde !”. Assurez-vous que votre programme a les autorisations nécessaires pour écrire dans le répertoire spécifié.\nLecture fgets() : Le premier paramètre de cette fonction permet de spécifier la variable qui stockera ce que retourne cette fonction. Le deuxième paramètre spécifie la taille maximale des données à lire. Le troisième paramètre nécessite un pointeur de fichier qui est utilisé pour lire le fichier. Donc la cible de la lecture. FILE *fptr; // Ouvrir en lecture fptr = fopen(\"fichier.txt\", \"r\"); // Créer une variable pour le contenu char myString[100]; // Mettre le contenu du fichier dans la variable fgets(myString, 100, fptr); // Afficher la variable printf(\"%s\", myString); // Fermer fclose(fptr); Bonne pratique C’est toujours une bonne idée de vérifier si le fichier à bien été ouvert. Ceci évite des comportements inattendus du code.\nFILE *fptr; // Ouvrir en lecture fptr = fopen(\"fichier.txt\", \"r\"); // Créer une variable pour le contenu char myString[100]; // Si le fichier existe if(fptr != NULL) { // Lire le fichier et afficher while(fgets(myString, 100, fptr)) { printf(\"%s\", myString); } // Fichier inexistant } else { printf(\"Impossible d'ouvrir le fichier.\"); } // Fermer fclose(fptr); Exercice Faites un programme qui demande à l’utilisateur d’entrer une phrase et sauvegarde chacun des mots sur une ligne séparée dans un fichier. Un conseil: utilisez fgets(pointeur,taille,stdin) pour lire ce qui est saisi par l’utilisateur. Passer des arguments à un programme Souvent il est utile de passer des arguments à un exécutable au moment où on l’appelle, par exemple le nom d’un fichier dans lequel on doit lire des données, etc. L’exemple suivant affiche “Bonjour” suivi de la chaîne de caractères passée au programme:\n#include \u003cstdio.h\u003e int main(int argc, char *argv[]) { printf(\"Bonjour %s\\n\", argv[1]); return 0; } Pour passer des arguments à un programme il faut définir des arguments à la fonction main(). Le premier est un entier qui contient le nombre d’arguments passés. Le deuxième est le tableau qui les contient.\nLe programme suivant fait la somme des deux nombres passés au programme:\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(int argc, char **argv) { int num1 = atoi(argv[1]); int num2 = atoi(argv[2]); int sum = num1 + num2; printf(\"%d\\n\",sum); return 0; } Dans ce programme, on remarque les choses suivantes:\n**argv est une autre manière de représenter *argv[], qui est un tableau de pointeurs atoi() est une fonction qui convertit une chaîne de caractères en entier. Il est recommandé de prévenir les erreurs en vérifiant le nombre d’arguments passé, comme suit:\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(int argc, char **argv) { if (argc != 3) { printf(\"Le programme a besoin de deux arguments!\\n\"); return 1; } int num1 = atoi(argv[1]); int num2 = atoi(argv[2]); int sum = num1 + num2; printf(\"%d\\n\",sum); return 0; } Gérer la mémoire Jusqu’ici nous avons vu comment allouer la mémoire de manière statique, au moment de la compilation. Dans le programme suivant par exemple, on stocke dans un tableau de taille 10 les caractères entrés sur la ligne de commande:\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main() { char mot[10]; char c; int i = 0; printf(\"Ecrivez un mot: \"); // Lire chaque caractère jusqu'à avoir '\\n' while ( (c = getchar()) != EOF \u0026\u0026 c != '\\n') { mot[i] = c; i++; } // Afficher le contenu de la mémoire char *p = mot; for (int j=0;j\u003c10;j++) { printf(\"Adresse: %p\\n\",p); printf(\"Valeur: %c\\n\\n\",*p); p++; } printf(\"Nombre de caracteres: %d\\n\", i); return 0; } Le problème avec ce code est que la chaîne de caractères entrée par l’utilisateur ne peut pas avoir une taille supérieure à 10.\nLa fonction malloc() permet de changer l’espace alloué à une variable pendant l’exécution du programme. Le code suivant demande à l’utilisateur la taille du mot avant de la définir:\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main() { char *mot; char c; int i; printf(\"Entrez le nombre de caracteres: \"); scanf(\"%d\",\u0026i); mot = (char *)malloc(i * sizeof(char)); printf(\"Ecrivez un mot: \"); getchar(); // Ignorer le '\\n' de l'input précédent i = 0; // Remettre à 0 while ( (c = getchar()) != EOF \u0026\u0026 c != '\\n') { mot[i] = c; i++; } // Afficher le contenu de a mémoire char *p = mot; for (int j=0;j\u003ci;j++) { printf(\"Adresse: %p\\n\",p); printf(\"Valeur: %c\\n\\n\",*p); p++; } free(mot); return 0; } La fonction malloc() prend la taille réelle qu’on veut allouer au pointeur mot, soit le nombre de caractères souhaité multiplié par la taille d’un caractère en mémoire. Elle retourne un pointeur au début de cet espace.\nLa fonction free() libère l’espace mémoire alloué au pointeur.\nPour changer la taille d’un espace préalablement défini avec malloc(), on peut utiliser malloc() une nouvelle fois mais il faudra alors copier le contenu de la mémoire dans le nouveau bloc alloué. Dans cette situation il est donc préférable d’utiliser realloc().\nDans l’exemple suivant, on utilise realloc() pour ajouter incrémenter la taille d’un espace mémoire à mesure que l’utilisateur entre des caractères:\nint main() { char *mot; char c; int i; // Donner une taille de 1 caractère mot = (char *)malloc(sizeof(char)); printf(\"Ecrivez un mot: \"); while ( (c = getchar()) != EOF \u0026\u0026 c != '\\n') { // Augmenter de 1 la taille de mot à chaque nouveau caractère mot = (char *)realloc(mot, (i + 1) * sizeof(char)); mot[i] = c; i++; } char *p = mot; for (int j=0;j\u003ci;j++) { printf(\"Adresse: %p\\n\",p); printf(\"Valeur: %c\\n\\n\",*p); p++; } free(mot); return 0; } La fonction realloc(*p,int) prend le pointeur dont on veut changer la taille et la nouvelle taille qu’on veut lui donner, puis retourne un pointeur au début de cet espace mémoire.",
    "description": "Dans cette section on verra comment lire et écrire dans les fichiers, passer des arguments à un programme et gérer la mémoire avec malloc(), realloc() et free().\nLecture et écriture dans des fichiers Lien vers w3school pour les fichiers en C, dont les notes sont très fortement inspirée\nÉcriture Inclusion de la bibliothèque standard C : Assurez-vous d’inclure la bibliothèque standard C en ajoutant la directive #include \u003cstdio.h\u003e au début de votre programme.",
    "tags": [],
    "title": "Divers",
    "uri": "/420-410/c/fichiers/index.html"
  },
  {
    "breadcrumb": "Le langage C",
    "content": "Exercice 1 Soit les variables suivantes:\nint liste[] = {23,66,1,21} // supposez que '23' est à l'adresse 0x77770210 int* p = liste; Quelles sont les valeurs des expressions suivantes?\nliste[2]+3 *p+liste[0] p+3 *p+3 *(p+3) Exercice 2 Faites un programme qui prend deux arguments, un mot et un caractère, et affiche le nombre de fois que le caractère apparaît dans la chaîne. Un exemple d’appel du programme:\npi@raspberry:~$ ./exo2 bonjour o 2 Exercice 3 Faites un programme qui prend un mot en argument, met la première moitié dans un tableau de char et la deuxième moitié dans un autre tableau de char. Utilisez malloc() pour définir leurs tailles. Par exemple, le mot bonjour sera retranscrit comme bonj et our.\nExercice 4 Faites un programme qui prend un nombre arbitraire d’arguments et les concatène dans un tableau de char. Par exemple:\npi@raspberry:~$ ./exo4 abc xyz qwerty créera un tableau qui contient la chaîne abcxyzqwerty.\nExercice 5 Faites un programme qui lit un fichier et affiche le nombre de lignes vides qu’il contient.\nExercice 6 Modifiez la fonction changerVal() afin qu’elle permette d’échanger les valeurs des deux variables a et b en utilisant des pointeurs.\nvoid changerVal(int x, int y) { int temp; temp = x; x = y; y = temp; } int main() { int a = 11; int b = 22; changerVal(\u0026a,\u0026b); printf(\"a=%d, b=%d\\n\",a,b); // Doit afficher \"a=22, b=11\" } Exercice 7 Utiliser un pointeur de type char pour afficher la valeur en hexadécimal de chacun des octets de la variable a (int est stocké sur 4 octets).\nint main() { int a = 64999; char *p; /* Votre code ici */ } Exercice 8 Faire la fonction lire_mem(char*, int) à partir du code précédent. Le premier paramètre est un pointeur sur char et le deuxième est le nombre d’itérations de la boucle. Utilisez ensuite cette fonction pour montrer le contenu de trois variables:\nint v1 = 25; float v2 = 34.908; long int v3 = 908445",
    "description": "Exercice 1 Soit les variables suivantes:\nint liste[] = {23,66,1,21} // supposez que '23' est à l'adresse 0x77770210 int* p = liste; Quelles sont les valeurs des expressions suivantes?\nliste[2]+3 *p+liste[0] p+3 *p+3 *(p+3) Exercice 2 Faites un programme qui prend deux arguments, un mot et un caractère, et affiche le nombre de fois que le caractère apparaît dans la chaîne. Un exemple d’appel du programme:\npi@raspberry:~$ ./exo2 bonjour o 2 Exercice 3 Faites un programme qui prend un mot en argument, met la première moitié dans un tableau de char et la deuxième moitié dans un autre tableau de char. Utilisez malloc() pour définir leurs tailles. Par exemple, le mot bonjour sera retranscrit comme bonj et our.",
    "tags": [],
    "title": "Exercices",
    "uri": "/420-410/c/exercices/index.html"
  },
  {
    "breadcrumb": "Sockets",
    "content": "Pour établir une communication entre un Raspberry Pi et un autre hôte sur le réseau, on peut adopter l’approche client-serveur:\nLe serveur est celui qui reçoit les messages Le client est celui qui envoit les messages Tout dépendant des applications, le Pi peut être n’importe lequel des deux.\nDeux protocoles réseau peuvent être utilisés pour envoyer des messages entre un client et un serveur, soit TCP et UDP.\nTCP: une connexion est établie entre client et serveur. Cette connexion est ensuite utilisée pour que les deux s’échangent des messages. Lorsqu’un des deux termine la connexion, celle-ci est fermée. UDP: le client envoit des messages au serveur sans établir de connexion préalable. Il n’est donc pas possible de savoir si le serveur est en ligne et prêt à recevoir les messages. Pour communiquer en utilisant TCP ou UDP, il faut utiliser les sockets.\nUn socket représente le point terminal d’une communication entre deux hôtes sur un réseau. Il peut être la source ou la destination d’un message. Les sockets sont définis par une adresse IP et un port et sont utilisés par les programmes pour envoyer et recevoir des messages.\nClient UDP Le programme suivant envoit un message par UDP sur un réseau. L’adresse de destination est 127.0.0.1 et le port est 8888:\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #define PORT 8888 #define DEST_IP \"127.0.0.1\" #define MESSAGE \"hello!\\n\" int main() { int sock = 0; struct sockaddr_in dest_addr; // Créer le socket sock = socket(AF_INET, SOCK_DGRAM, 0); // Initialiser la struct de l'adresse IP memset(\u0026dest_addr, 0, sizeof(dest_addr)); dest_addr.sin_family = AF_INET; dest_addr.sin_addr.s_addr = inet_addr(DEST_IP); dest_addr.sin_port = htons(PORT); // Envoyer le message sendto(sock, (const char *)MESSAGE, strlen(MESSAGE), MSG_CONFIRM, (const struct sockaddr *)\u0026dest_addr, sizeof(dest_addr)); // Fermer le socket close(sock); return 0; } Vous pouvez tester ce programme comme suit: à partir d’un hôte sur le même réseau que le Pi, ouvrez un port UDP en mode “listen” avec la commande nc. Cet hôte joue donc le rôle de serveur. Par exemple, pour ouvrir le port UDP 8888 la commande est la suivante :\nnc -ulp 8888 Assurez-vous que la variable DEST_IP du programme a bien comme valeur l’adresse de l’hôte où vous avez lancé la commande nc.\nTCP Le programme suivant envoit un message par TCP sur un réseau. L’adresse de destination est 127.0.0.1 et le port est 8888:\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #define PORT 8888 #define DEST_IP \"127.0.0.1\" #define MESSAGE \"hello!\\n\" int main() { int sock = 0; struct sockaddr_in dest_addr; // Créer le socket sock = socket(AF_INET, SOCK_STREAM, 0); // Initialiser la struct de l'adresse IP memset(\u0026dest_addr, '0', sizeof(dest_addr)); dest_addr.sin_family = AF_INET; dest_addr.sin_addr.s_addr = inet_addr(DEST_IP); dest_addr.sin_port = htons(PORT); // Créer la connexion connect(sock, (struct sockaddr *)\u0026dest_addr, sizeof(dest_addr)); // Envoyer le message et fermer la connexion send(sock, MESSAGE, strlen(MESSAGE), 0); close(sock); return 0; } Vous pouvez tester ce programme avec la commande nc. À partir d’un hôte sur le même réseau que le Pi (qui aura le rôle de serveur), ouvrez un port TCP en mode “listen” au port UDP 8888:\nnc -lp 8888 Assurez-vous que la variable DEST_IP du programme a bien comme valeur l’adresse de l’hôte où vous avez lancé la commande nc; ensuite exécutez-le.\nServeur UDP Le programme suivant ouvre un socket au port UDP 8888 et affiche les messages entrants:\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #define PORT 8888 #define BUFFER_SIZE 1024 int main() { int socket_local; struct sockaddr_in adr_local, adr_dist; char buffer[BUFFER_SIZE]; // Créer le socket et initialiser l'adresse socket_local = socket(AF_INET, SOCK_DGRAM, 0); memset(\u0026adr_local, 0, sizeof(adr_local)); adr_local.sin_family = AF_INET; adr_local.sin_addr.s_addr = INADDR_ANY; adr_local.sin_port = htons(PORT); // Associer le socket à l'adresse de l'interface bind(socket_local, (const struct sockaddr *)\u0026adr_local, sizeof(adr_local)); // Réception des messages while (1) { int len, n; len = sizeof(adr_dist); // Stocker le message reçu dans n n = recvfrom(socket_local, (char *)buffer, BUFFER_SIZE, MSG_WAITALL, (struct sockaddr *)\u0026adr_dist, \u0026len); buffer[n] = '\\0'; // Afficher printf(\"Reçu: %s\", buffer); fflush(stdout); } close(socket_local); return 0; } Pour tester ce programme à partir d’un autre hôte (qui agit comme client), lancez la commande nc (remplacez 1.2.3.4 par l’adresse IP du serveur) et tapez le message que vous voulez envoyer:\nnc -u 1.2.3.4 8888 Bonjour! TCP Le programme suivant ouvre un socket au port TCP 8888 et attend les connexions entrantes. Lorsque la connexion est établie il affiche les messages et termine la connexion lorsque le message reçu est vide (taille 0):\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003cstring.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #define PORT 8888 #define BUFFER_SIZE 1024 int main() { int socket_local, socket_dist; struct sockaddr_in address; int addrlen = sizeof(address); char buffer[BUFFER_SIZE] = {0}; // Créer le socket et initialiser l'adresse socket_local = socket(AF_INET, SOCK_STREAM, 0); memset(\u0026address, 0, sizeof(address)); address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); // Associer le socket à l'adresse de l'interface bind(socket_local, (struct sockaddr *)\u0026address, sizeof(address)); // Attendre une connexion entrante listen(socket_local, 3); socket_dist = accept(socket_local, (struct sockaddr *)\u0026address, (socklen_t*)\u0026addrlen); // Réception des messages while(1) { int datalen; // Stocker le message datalen = read(socket_dist, buffer, BUFFER_SIZE); if (datalen == 0) { printf(\"Déconnexion\\n\"); break; } else { // Afficher le message printf(\"Reçu: %s\", buffer); fflush(stdout); } memset(buffer, 0, BUFFER_SIZE); } close(socket_dist); close(socket_local); return 0; } Pour tester ce programme à partir d’un autre hôte (qui agit comme client), lancez la commande nc (remplacez 1.2.3.4 par l’adresse IP du serveur) et tapez le message que vous voulez envoyer:\nnc 1.2.3.4 8888 Bonjour! Exercices UDP Créez un serveur UDP sur votre PI qui s’attend à recevoir l’une des trois commande suivante: allume, ferme, exit.\nallume : allume une led ferme : ferme cette led exit : S’assure de fermer la led et de bien fermer le serveur. Créez ensuite le client UDP sur votre ordinateur (pas le Pi). Ce client doit pouvoir envoyer ces trois messages mentionné ci-dessus.\nTCP Source\nFaites deux programmes (serveur1.c et client1.c) ayant les mêmes fonctionnalités que celui de l’exercice précédent, mais en utilisant une connexion TCP. Au message exit, la connexion TCP est fermée des deux côtés. Solution client1.c\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #define PORT 9090 #define DEST_IP \"10.10.20.245\" int main() { int sock = 9090; struct sockaddr_in dest_addr; // Créer le socket sock = socket(AF_INET, SOCK_STREAM, 0); // ** SOCK_STREAM ** // // Initialiser la struct de l'adresse IP memset(\u0026dest_addr, '0', sizeof(dest_addr)); dest_addr.sin_family = AF_INET; dest_addr.sin_addr.s_addr = inet_addr(DEST_IP); dest_addr.sin_port = htons(PORT); // Créer la connexion connect(sock, (struct sockaddr *)\u0026dest_addr, sizeof(dest_addr)); while (1) { printf(\"\u003e \"); char message[100]; fgets(message,sizeof(message),stdin); send(sock, message, strlen(message), 0); // ** MODIFIÉ **// if(strcmp(message,\"exit\\n\") == 0){ break; } } close(sock); return 0; } serveur1.c\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003cpigpio.h\u003e #define LED_PIN 17 #define PORT 9090 #define BUFFER_SIZE 1024 int main() { int socket_local, socket_desc; struct sockaddr_in address; int addrlen = sizeof(address); // ** AJOUTE ** // char buffer[BUFFER_SIZE] = {0}; // Initialiser GPIO if (gpioInitialise() \u003c 0) { fprintf(stderr, \"Erreur d'initialisation pigpio\\n\"); return 1; } // Créer le socket et initialiser l'adresse socket_local = socket(AF_INET, SOCK_STREAM, 0); // ** SOCK_STREAM ** // memset(\u0026address, 0, sizeof(address)); address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); // Associer le socket à l'adresse de l'interface bind(socket_local, (struct sockaddr *)\u0026address, sizeof(address)); // Attendre une connexion entrante listen(socket_local, 3); socket_desc = accept(socket_local, (struct sockaddr *)\u0026address, (socklen_t*)\u0026addrlen); // Réception des messages while(1) { int datalen; // Stocker le message datalen = read(socket_desc, buffer, BUFFER_SIZE); // ** read ** // if (datalen != 0) { printf(\"\u003c %s\",buffer); if(strcmp(buffer,\"allume\\n\") == 0){ gpioWrite(LED_PIN, 1); } else if(strcmp(buffer,\"ferme\\n\") == 0){ gpioWrite(LED_PIN, 0); } else if(strcmp(buffer,\"exit\\n\") == 0){ gpioWrite(LED_PIN, 0); gpioTerminate(); break; } } memset(buffer, 0, BUFFER_SIZE); } close(socket_desc); // ** AJOUTE ** // close(socket_local); return 0; } Ajoutez le fonctionnalité suivante: le serveur répond “OK” au client si la commande est allume, ferme ou exit ou “ERR” autrement (serveur2.c et client2.c). Solution client2.c\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #define PORT 9090 #define DEST_IP \"10.10.20.245\" #define ANSWER_LEN 4 // ** AJOUTE ** // int main() { int sock = 0; struct sockaddr_in dest_addr; // Créer le socket sock = socket(AF_INET, SOCK_STREAM, 0); // Initialiser la struct de l'adresse IP memset(\u0026dest_addr, '0', sizeof(dest_addr)); dest_addr.sin_family = AF_INET; dest_addr.sin_addr.s_addr = inet_addr(DEST_IP); dest_addr.sin_port = htons(PORT); // Créer la connexion connect(sock, (struct sockaddr *)\u0026dest_addr, sizeof(dest_addr)); while (1) { printf(\"\u003e \"); char message[100]; char answer[4]; fgets(message,sizeof(message),stdin); send(sock, message, strlen(message), 0); if(strcmp(message,\"exit\\n\") == 0){ break; } else { // ** ELSE AJOUTE ** // // Afficher réponse recv(sock, answer, ANSWER_LEN, 0); printf(\"\u003c %s\\n\",answer); } } close(sock); return 0; } serveur2.c\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003cpigpio.h\u003e #define LED_PIN 17 #define PORT 9090 #define BUFFER_SIZE 1024 #define ANSWER_LEN 4 // ** AJOUTE ** // int main() { int socket_local, socket_desc; struct sockaddr_in address; int addrlen = sizeof(address); char buffer[BUFFER_SIZE] = {0}; char answer[4]; // Initialiser GPIO if (gpioInitialise() \u003c 0) { fprintf(stderr, \"Erreur d'initialisation pigpio\\n\"); return 1; } // Créer le socket et initialiser l'adresse socket_local = socket(AF_INET, SOCK_STREAM, 0); memset(\u0026address, 0, sizeof(address)); address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); // Associer le socket à l'adresse de l'interface bind(socket_local, (struct sockaddr *)\u0026address, sizeof(address)); // Attendre une connexion entrante listen(socket_local, 3); socket_desc = accept(socket_local, (struct sockaddr *)\u0026address, (socklen_t*)\u0026addrlen); // Réception des messages while(1) { int datalen; strcpy(answer,\"OK\"); // ** AJOUTE ** // // Stocker le message datalen = read(socket_desc, buffer, BUFFER_SIZE); if (datalen != 0) { printf(\"\u003c %s\",buffer); if(strcmp(buffer,\"allume\\n\") == 0){ gpioWrite(LED_PIN, 1); } else if(strcmp(buffer,\"ferme\\n\") == 0){ gpioWrite(LED_PIN, 0); } else if(strcmp(buffer,\"exit\\n\") == 0){ gpioWrite(LED_PIN, 0); gpioTerminate(); break; } else { // ** AJOUTE ** // strcpy(answer,\"ERR\"); } send(socket_desc, answer, ANSWER_LEN, 0); } memset(buffer, 0, BUFFER_SIZE); } close(socket_desc); close(socket_local); return 0; } Modifiez votre programme: lorsque le client envoit exit, la connexion TCP est terminée, le client se termine, mais le serveur continue à attendre d’autres connexions TCP (serveur3.c et client3.c). Solution client3.c\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003carpa/inet.h\u003e #define PORT 9090 #define DEST_IP \"10.10.20.245\" #define ANSWER_LEN 4 int main() { int sock = 0; struct sockaddr_in dest_addr; // Créer le socket sock = socket(AF_INET, SOCK_STREAM, 0); // Initialiser la struct de l'adresse IP memset(\u0026dest_addr, '0', sizeof(dest_addr)); dest_addr.sin_family = AF_INET; dest_addr.sin_addr.s_addr = inet_addr(DEST_IP); dest_addr.sin_port = htons(PORT); // Créer la connexion connect(sock, (struct sockaddr *)\u0026dest_addr, sizeof(dest_addr)); while (1) { printf(\"\u003e \"); char message[100]; char answer[4]; fgets(message,sizeof(message),stdin); send(sock, message, strlen(message), 0); // Afficher réponse // ** MODIFIE ** // recv(sock, answer, ANSWER_LEN, 0); printf(\"\u003c %s\\n\",answer); if(strcmp(answer,\"BYE\") == 0) { break; } } close(sock); return 0; } serveur3.c\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003cpigpio.h\u003e #define LED_PIN 17 #define PORT 9090 #define BUFFER_SIZE 1024 #define ANSWER_LEN 4 int main() { int socket_local, socket_desc; struct sockaddr_in address; int addrlen = sizeof(address); char buffer[BUFFER_SIZE] = {0}; char answer[4]; // Initialiser GPIO if (gpioInitialise() \u003c 0) { fprintf(stderr, \"Erreur d'initialisation pigpio\\n\"); return 1; } // Créer le socket et initialiser l'adresse socket_local = socket(AF_INET, SOCK_STREAM, 0); memset(\u0026address, 0, sizeof(address)); address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); // Associer le socket à l'adresse de l'interface bind(socket_local, (struct sockaddr *)\u0026address, sizeof(address)); while (1) { // ** AJOUTE WHILE ** // // Attendre une connexion entrante listen(socket_local, 3); socket_desc = accept(socket_local, (struct sockaddr *)\u0026address, (socklen_t*)\u0026addrlen); // Réception des messages while(1) { int datalen; strcpy(answer,\"OK\"); // Stocker le message datalen = read(socket_desc, buffer, BUFFER_SIZE); if (datalen != 0) { printf(\"\u003c %s\",buffer); if(strcmp(buffer,\"allume\\n\") == 0){ gpioWrite(LED_PIN, 1); } else if(strcmp(buffer,\"ferme\\n\") == 0){ gpioWrite(LED_PIN, 0); } else if(strcmp(buffer,\"exit\\n\") == 0){ gpioWrite(LED_PIN, 0); strcpy(answer,\"BYE\"); // ** AJOUTE ** // send(socket_desc, answer, ANSWER_LEN, 0); // ** AJOUTE ** // break; } else { strcpy(answer,\"ERR\"); } send(socket_desc, answer, ANSWER_LEN, 0); } memset(buffer, 0, BUFFER_SIZE); } close(socket_desc); // ** MODIFIÉ ** // } close(socket_local); gpioTerminate(); return 0; } Ajoutez un 2e module LED sur votre Pi. Modifiez le programme (serveur4.c et client4.c) pour que les commandes envoyées permettent de spécifier laquelle des 2 LED allumer (les messages “led1” et “led2” doivent être envoyés au serveur pour qu’il sache quelle LED allumer ou éteindre). Les messages possibles du client sont donc: led1, led2, allume, ferme, exit. Les messages du serveur sont OK, ERR, BYE. Solution client4.c\nPas de changements\nserveur4.c\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003cpigpio.h\u003e #define LED_PIN 17 #define PORT 9090 #define BUFFER_SIZE 1024 #define ANSWER_LEN 4 #define LED_1 17 // ** AJOUTE ** // #define LED_2 24 // ** AJOUTE ** // int main() { int socket_local, socket_desc; struct sockaddr_in address; int addrlen = sizeof(address); char buffer[BUFFER_SIZE] = {0}; char answer[4]; int led_pin = LED_1; // ** AJOUTE ** // // Initialiser GPIO if (gpioInitialise() \u003c 0) { fprintf(stderr, \"Erreur d'initialisation pigpio\\n\"); return 1; } // Créer le socket et initialiser l'adresse socket_local = socket(AF_INET, SOCK_STREAM, 0); memset(\u0026address, 0, sizeof(address)); address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); // Associer le socket à l'adresse de l'interface bind(socket_local, (struct sockaddr *)\u0026address, sizeof(address)); while (1) { // Attendre une connexion entrante listen(socket_local, 3); socket_desc = accept(socket_local, (struct sockaddr *)\u0026address, (socklen_t*)\u0026addrlen); // Réception des messages while(1) { int datalen; strcpy(answer,\"OK\"); // Stocker le message datalen = read(socket_desc, buffer, BUFFER_SIZE); if (datalen != 0) { printf(\"\u003c %s\",buffer); if(strcmp(buffer,\"allume\\n\") == 0){ gpioWrite(led_pin, 1); } else if(strcmp(buffer,\"ferme\\n\") == 0){ gpioWrite(led_pin, 0); } else if(strcmp(buffer,\"exit\\n\") == 0){ gpioWrite(LED_1, 0); // ** AJOUTE ** // gpioWrite(LED_2, 0); // ** AJOUTE ** // strcpy(answer,\"BYE\"); send(socket_desc, answer, ANSWER_LEN, 0); break; } else if(strcmp(buffer,\"led1\\n\") == 0){ // ** AJOUTE ** // led_pin = LED_1; } else if(strcmp(buffer,\"led2\\n\") == 0){ // ** AJOUTE ** // led_pin = LED_2; } else { strcpy(answer,\"ERR\"); } send(socket_desc, answer, ANSWER_LEN, 0); } memset(buffer, 0, BUFFER_SIZE); } close(socket_desc); } close(socket_local); gpioTerminate(); return 0; }",
    "description": "Pour établir une communication entre un Raspberry Pi et un autre hôte sur le réseau, on peut adopter l’approche client-serveur:\nLe serveur est celui qui reçoit les messages Le client est celui qui envoit les messages Tout dépendant des applications, le Pi peut être n’importe lequel des deux.\nDeux protocoles réseau peuvent être utilisés pour envoyer des messages entre un client et un serveur, soit TCP et UDP.\nTCP: une connexion est établie entre client et serveur. Cette connexion est ensuite utilisée pour que les deux s’échangent des messages. Lorsqu’un des deux termine la connexion, celle-ci est fermée. UDP: le client envoit des messages au serveur sans établir de connexion préalable. Il n’est donc pas possible de savoir si le serveur est en ligne et prêt à recevoir les messages. Pour communiquer en utilisant TCP ou UDP, il faut utiliser les sockets.",
    "tags": [],
    "title": "TCP et UDP",
    "uri": "/420-410/sockets/tcp-udp/index.html"
  },
  {
    "breadcrumb": "REST",
    "content": "Pour contrôler à distance des modules connectés sur le Pi, une technique consiste à utiliser une API. À partir d’une page web, on pourra ainsi faire des appels d’API pour allumer une LED, activer des servos, lire les données d’un capteur, etc.\nCette API doit donc s’exécuter sur le Pi. Pour cela nous utilisersons Node et Express.\nInstallation Node Sur le Pi, en tant que root, installez Node et le gestionnaire de paquets npm:\napt update apt install nodejs npm Vérifiez que l’installation est correcte avec les commandes node -v et npm -v. Elles devraient respectivement afficher v12.22.12 et 7.5.2.\nExpress Nous allons créer un répertoire nommé rest pour les fichiers de notre API et y installer le framework Express. Les commandes sont les suivantes:\nmkdir rest cd rest npm init npm install express npm init La commande npm init a pour but de créer le fichier package.json; celui-ci contient différentes informations sur votre application. Pour ce faire, npm init vous pose quelques questions. Ici, vous pouvez choisir les réponses par défaut en faisant enter pour chacune.\nTest Le serveur que nous avons installé est structuré de la manière la plus simple possible: nous avons simplement défini un point d’entrée, qui correspond à l’attribut “main” dans le fichier package.json (index.js par défaut). Il est donc possible de mettre tout le code de notre API dans cet unique fichier.\nOn définit donc une première route pour tester notre installation. Celle-ci affiche “Bonjour le monde!” à la racine du site. Créez le fichier index.js et mettez-y le contenu suivant:\nconst express = require('express') const app = express() const port = 3000 app.get('/', (req, res) =\u003e { res.send('Bonjour le monde!') }) app.listen(port, () =\u003e { console.log(`Application roule sur port ${port}`) }) Lancez ensuite l’application avec la commande nodejs index.js. Vous pourrez y accéder en ouvrant une page web au port 3000 de votre Pi.",
    "description": "Pour contrôler à distance des modules connectés sur le Pi, une technique consiste à utiliser une API. À partir d’une page web, on pourra ainsi faire des appels d’API pour allumer une LED, activer des servos, lire les données d’un capteur, etc.\nCette API doit donc s’exécuter sur le Pi. Pour cela nous utilisersons Node et Express.\nInstallation Node Sur le Pi, en tant que root, installez Node et le gestionnaire de paquets npm:",
    "tags": [],
    "title": "Installation",
    "uri": "/420-410/rest/installation/index.html"
  },
  {
    "breadcrumb": "REST",
    "content": "Puisqu’on veut avoir une API, il faut définir ses points terminaux (“endpoints”). Il s’agit donc de créer les routes correspondantes et d’y ajouter le code nécessaire pour envoyer ou recevoir des données au format JSON.\n/info À titre d’exemple, nous allons créer un premier point terminal pour afficher des informations sur l’hôte, soit son nom et la date et l’heure du système. On souhaite que les données retournées aient le format suivant:\n{ \"hostname\": \"raspberry\", \"date\": \"2024-03-03\" } On utilisera l’objet Date de javascript pour récupérer la date et os.hostname() pour le nom de l’hôte. Attention, pour utiliser cette dernière fonction vous devez inclure le module “os” avec la commande const os = require(\"os\"); dans votre fichier index.js.\nAjoutez la route suivante à votre code:\napp.get('/info', (req, res) =\u003e { const info = { \"hostname\": os.hostname(), \"date\": new Date().toString() }; res.send(info); }) Pour tester, ouvrez une page à cet endpoint; par exemple si votre Pi est à l’adresse 10.10.10.100 vous devrez ouvrir une page à http://10.10.10.100:3000/info.\nLire une valeur digitale du GPIO Dans cet exemple nous utilisons un bouton sur le GPIO 18 du Pi, puis le endpoint getBTN pour lire l’état du bouton (1 ou 0).\nPour accéder au GPIO à partir de javascript on peut utiliser le module onoff. Il faut tout d’abord l’installer avec la commande suivante:\nnpm install onoff Ensuite on doit:\nImporter le module à l’aide de la fonction require(); Déclarer le numéro de GPIO sur lequel on veut lire les données; Utiliser la méthode readSync() pour lire la valeur; Votre programme devrait donc ressembler à ceci:\nconst express = require('express'); const { Gpio } = require('onoff'); // Importer module onoff const BTN = new Gpio(18, 'in'); // GPIO 18 en mode lecture const app = express() const port = 3000 app.get('/', (req, res) =\u003e { res.send('Bonjour le monde!') }) // Retourne le JSON { state: 1 } ou { state: 0 } app.get('/getBTN', (req, res) =\u003e { const bouton = { \"state\": BTN.readSync() // Lire la valeur }; res.send(bouton); }) app.listen(port, () =\u003e { console.log(`Application roule sur port ${port}`) }) Écrire une valeur digitale vers le GPIO Dans cet exemple on suppose qu’un module LED est connecté sur le port GPIO 17 du Pi.\nOn ajoutera le endpoint setLED à notre API. Celui-ci recevra des informations au format JSON suivant:\n{ state: 1 } L’attribut state peut être 1 ou 0 selon qu’on veut allumer ou éteindre la LED.\nOn utilisera le module onoff installé précédemment pour accéder au GPIO. Dans votre fichier index.js, il faut inclure le module onoff et définir la broche qui enverra le signal avec les instructions suivantes:\nconst LED = new Gpio(17, 'out'); Le module body-parser sera utilisé pour récupérer les valeurs JSON. Installez-le tout d’abord avec la commande suivante:\nnpm install body-parser Ensuite ajoutez cette instruction à votre fichier index.js:\napp.use(express.json()); Enfin, ajoutez le code suivant pour définir votre endpoint:\napp.post('/setLED', (req, res) =\u003e { const { state } = req.body; if (state !== 0 \u0026\u0026 state !== 1) { return res.status(400).json({ message: 'Erreur: valeur différente de 0 ou 1' }); } LED.writeSync(state); }); Test Pour tester votre programme, il y a plusieurs possibilités.\nUtiliser une extension Firefox comme “postman” ou “rested” qui permet d’envoyer des appels d’API L’utilitaire curl pour faire un appel directement d’une ligne de commande linux: curl -X POST http://10.10.10.100:3000/setLED -H \"Content-Type: application/json\" -d '{\"valeur\": 1}' Une page HTML simple dont le code fait les appels d’API à tester, comme l’exemple suivant: \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTest API\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton id=\"bouton\"\u003eLED\u003c/button\u003e \u003cscript\u003e const button = document.getElementById(\"bouton\"); button.addEventListener(\"click\", () =\u003e { fetch(\"http://10.10.10.100:3000/setLED\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ state: 1 }) }) .then(response =\u003e { if (!response.ok) { throw new Error(\"Erreur de la requête\"); } console.log(\"LED allumée\"); }) .catch(error =\u003e { console.error(\"Erreur:\", error); }); }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Exercice Connectez la LED RGB et faites 2 endpoints: setRGB, qui change la couleur de la LED ou l’éteint et peut prendre 4 valeurs (“red”,“green”,“blue” et “off”) pour un attribut nommé “state”, et getRGB qui retourne des données au même format JSON selon l’état de la LED.\nCodez ensuite une page HTML en vous basant sur l’exemple précédent; cette page doit comprendre 4 boutons pour changer l’état de la LED et un bouton pour afficher sur la page la couleur courante de la LED.",
    "description": "Puisqu’on veut avoir une API, il faut définir ses points terminaux (“endpoints”). Il s’agit donc de créer les routes correspondantes et d’y ajouter le code nécessaire pour envoyer ou recevoir des données au format JSON.\n/info À titre d’exemple, nous allons créer un premier point terminal pour afficher des informations sur l’hôte, soit son nom et la date et l’heure du système. On souhaite que les données retournées aient le format suivant:",
    "tags": [],
    "title": "API",
    "uri": "/420-410/rest/api/index.html"
  },
  {
    "breadcrumb": "MQTT",
    "content": "Le protocole MQTT, pour Message Queuing Telemetry Transport, est un protocole conçu pour les objets connectés: il est simple à mettre en place et à utiliser et consomme peu de ressources et de bande passante. Il permet une communication facile entre un ensemble d’objets connectés et les différentes applications qui les utilisent.\nModèle de communication En MQTT, les objets connectés et les applications sont des clients; il se connectent à un serveur (aussi appelé “broker” ou agent) qui gère la communication entre eux:\nLes clients peuvent émettre des données ou encore recevoir des données. Lorsqu’ils génèrent des données, ils envoient un message publish à l’agent; lorsqu’ils souhaitent reçevoir des données, ils envoient un message subscribe à l’agent, et celui-ci leur enverra les données à mesure qu’elles seront publiées par les autres clients.\nLes messages envoyés et reçus doivent être identifiés par une rubrique (ou “topic”). Un client qui s’abonne à une rubrique ne recevra que les messages envoyés à cette rubrique.\nImaginez par exemple une application web qui affiche des données environnementales (température, humidité, luminosité, etc.) lues sur des senseurs situés à différents endroits dans votre maison. Les contrôleurs (RaspberryPi, Arduino, etc.) sur lesquels sont connectés les senseurs publieront des données à intervalles réguliers en les envoyant à l’agent sur la rubrique “maison”. Votre application contactera l’agent pour s’abonner à la rubrique “maison”, et recevra ainsi toutes les données dont elle a besoin, sans avoir besoin de se connecter individuellement sur chaque contrôleur.\nQuelques mots sur les topics Les rubriques MQTT sont représentées par des chaînes de caractères et peuvent être organisées en hiérarchie. Par exemple on peut avoir une rubrique nommée “maison”, mais aussi “maison/salon”, “maison/chambre1”, “maison/chambre1/luminosité”, etc.\nCaractères spéciaux Les caractères + et # peuvent être utilisés dans les désignations de rubriques.\nImaginez une maison entièrement connectée où on utilise les rubriques MQTT suivantes:\nmaison/salon/temp maison/salon/lumi maison/salon/bruit maison/cuisine/temp maison/cuisine/lumi maison/cuisine/bruit Le caractère + peut remplacer un niveau afin de s’abonner à des sous-rubriques communes à plusieurs niveaux. Par exemple, si un client s’abonne à maison/+/lumi, il recevra les messages de maison/salon/lumi et maison/cuisine/lumi.\nLe caractère # ne peut être utilisé qu’à la fin d’une rubrique, et permet de s’abonner à toutes les sous-rubriques. Par exemple, un client qui s’abonne à maison/salon/# recevra les messages de maison/salon/temp, maison/salon/lumi et maison/salon/bruit.\nAttention! Les caractères # et + ne peuvent pas être utilisés pour publier des messages. On ne peut s’en servir que dans les abonnements.\n$SYS La plupart des implémentations de MQTT ont une rubrique $SYS qui permet d’accéder à des informations sur l’agent. Par exemple, $SYS/broker/clients/maximum donne le nombre maximum de clients connectés; $SYS/broker/publish/messages/received donne le nombre de messages publiés par des clients sur ce broker; etc.\nIl n’est pas possible de publier sous cette rubrique.\nQoS QoS, pour “Quality of Service”, est un terme utilisé en informatique pour désigner des contraintes sur la distribution des messages sur un réseau. Par exemple, on peut définir des règles de QoS sur les routeurs dans un réseau afin de donner une priorité plus grande aux paquets qui contiennent de la vidéo en streaming; ou encore on peut limiter la bande passante utilisée par des paquets du protocole bitTorrent; etc.\nEn MQTT, il y a 3 niveaux de QoS. Chaque niveau désigne les caractéristiques reliées au traitement des messages; plus précisément, au niveau de fiabilité de la transmission:\n0: basse (“Fire and Forget”) 1: moyenne (“Acknowledge Deliver”) 2: haute (“Assured Delivery”) Un client qui envoit un message avec un QoS de 0 ne reçoit aucun accusé de réception.\nUn client qui envoit un message envoyé avec un QoS de 1 reçoit un accusé de réception.\nUn client qui envoit un message envoyé avec un QoS de 2 reçoit un accusé de réception, et une confirmation lorsque le message est livré aux abonnés.\nLa valeur du QoS est déterminée lors de l’envoi d’un message (côté émetteur) et lors de l’abonnement (côté récepteur).\nCas d’utilisation QoS 0: À utiliser lorsque la connexion est assez stable ou que la perte occasionnelle de messages n’est pas un problème. Qos 1: À utiliser lorsqu’on souhaite avoir tous les messages, mais qu’on accepte d’avoir des messages répétés à l’occasion. QoS 2: À utiliser lorsqu’on souhaite avoir tous les messages et qu’on ne veut pas avoir de messages qui se répètent. Authentification MQTT supporte des fonctionnalités d’authentification. Lorsqu’on les active, tous les clients devront fournir un identifiant et un mot de passe à l’agent au moment de la connexion.\nC’est la configuration de l’agent (“broker”) qui détermine si les clients doivent s’authentifier: dans le fichier de configuration du broker /etc/mosquitto/mosquitto.conf, la variable allow_anonymous doit être à false, et password_file doit indiquer le fichier qui contient les identifiants et mots de passe. Par exemple:\nallow_anonymous false password_file /etc/mosquitto/users On peut créer autant d’utilisateurs qu’il y a de clients qui se connectent, mais il est aussi possible que plusieurs clients se partagent les mêmes identifiants.\nLa commande mosquitto_passwd permet de créer le fichier des identifiants.\nAttention MQTT ne définit pas de méthodes de chiffrement. Ainsi les mots de passe et identifiants sont transmis en clair lors de la connexion. Si on souhaite chiffrer les communications, il faut utiliser des outils tiers comme par exemple le protocole TLS.\nIdentification des clients Les commandes mosquitto_sub et mosquitto_pub utilisent les options -u et -P pour passer respectivement le nom d’utilisateur et le mot de passe à l’agent:\nmosquitto_pub -h 192.168.0.10 -u nom_utilisateur -P mot_de_passe -t \"sujet\" -m \"Bonjour\" Dans un programme C qui utilise la librairie mosquitto, il faut appeler la fonction mosquitto_username_pw_set() (avant la connexion) pour définir les identifiants à utiliser lors de la connexion. Voir https://mosquitto.org/api/files/mosquitto-h.html#Username_and_password pour plus de détails.",
    "description": "Le protocole MQTT, pour Message Queuing Telemetry Transport, est un protocole conçu pour les objets connectés: il est simple à mettre en place et à utiliser et consomme peu de ressources et de bande passante. Il permet une communication facile entre un ensemble d’objets connectés et les différentes applications qui les utilisent.\nModèle de communication En MQTT, les objets connectés et les applications sont des clients; il se connectent à un serveur (aussi appelé “broker” ou agent) qui gère la communication entre eux:",
    "tags": [],
    "title": "Description",
    "uri": "/420-410/mqtt/intro/index.html"
  },
  {
    "breadcrumb": "MQTT",
    "content": "Pour le cours, SVP utilisez l’agent MQTT disponible sur le réseau interne au nom mqttbroker.lan.\nDans ce cours nous utiliserons Mosquitto. Cette implémentation de MQTT, développée par la fondation Eclipse, fournit des utilitaires de ligne de commande pour envoyer et recevoir des messages (mosquitto_pub et mosquitto_sub), et aussi des librairies permettant d’implémenter des clients MQTT en C/C++.\nAgent MQTT Mosquitto Pour installer le service mosquitto, lancez la commande suivante:\napt update apt install mosquitto Configuration de base Les paramètres de configuration de mosquitto sont définis dans le fichier /etc/mosquitto/mosquitto.conf.\nPour utiliser mosquitto sans authentification, assurez-vous d’avoir la valeur true pour la directive allow_anonymous. Aussi, vérifiez que listener est bien au port 1883 et que mosquitto écoute sur toutes les interfaces (valeur 0.0.0.0). Ceci correspond aux lignes suivantes dans le fichier:\nlistener 1883 0.0.0.0 allow_anonymous true Laissez les autres valeurs inchangées.\nLorsque vous avez modifié la configuration, lancez les commandes suivantes pour démarrer le service puis pour l’activer au démarrage du serveur:\nsystemctl start mosquitto systemctl enable mosquitto Note Nous verrons dans la section Sécurité comment activer l’authentification et le chiffrement dans mosquitto.\nClient MQTT Mosquitto Pour installer les logiciels et librairies pour la partie client, lancez la commande suivante:\napt update apt install mosquitto-clients libmosquitto-dev Pour tester l’installation, lancez le client “abonné” à l’aide de la commande suivante:\nmosquitto_sub -h mqttbroker.lan -t 'test' (Vous pouvez choisir un autre nom de rubrique que ’test')\nEnsuite publiez un message (à partir du même hôte ou d’un autre hôte sur le même réseau) comme suit:\nmosquitto_pub -h mqttbroker.lan -t 'test' -m 'Ceci est un test' “Subscriber” en C mqtt_sub.c\ngcc -o mqtt_sub mqtt_sub.c -lmosquitto #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cmosquitto.h\u003e #define MQTT_BROKER_HOST \"mqttbroker.lan\" #define MQTT_PORT 1883 #define MQTT_TOPIC \"rubrique\" #define MQTT_QOS 1 void on_connect(struct mosquitto *mosq, void *userdata, int result) { if (result == 0) { mosquitto_subscribe(mosq, NULL, MQTT_TOPIC, MQTT_QOS); } else { fprintf(stderr, \"Erreur: connexion broker MQTT.\\n\"); } } void on_message(struct mosquitto *mosq, void *userdata, const struct mosquitto_message *message) { printf(\"Message: (%s) %s\\n\",message-\u003etopic, (char *)message-\u003epayload); } int main() { struct mosquitto *mosq = NULL; int rc; mosquitto_lib_init(); mosq = mosquitto_new(NULL, true, NULL); if (!mosq) { fprintf(stderr, \"Erreur: création de l'instance mosquitto.\\n\"); return 1; } mosquitto_connect_callback_set(mosq, on_connect); mosquitto_message_callback_set(mosq, on_message); rc = mosquitto_connect(mosq, MQTT_BROKER_HOST, MQTT_PORT, 60); if (rc != MOSQ_ERR_SUCCESS) { fprintf(stderr, \"Connexion impossible au broker: %s\\n\", mosquitto_strerror(rc)); return 1; } mosquitto_loop_forever(mosq, -1, 1); mosquitto_destroy(mosq); mosquitto_lib_cleanup(); return 0; } “Publisher” en C mqtt_pub.c\ngcc -o mqtt_pub mqtt_pub.c -lmosquitto #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cmosquitto.h\u003e #define MQTT_BROKER_HOST \"mqttbroker.lan\" #define MQTT_PORT 1883 #define MQTT_TOPIC \"rubrique\" #define MQTT_QOS 0 #define MQTT_MESSAGE \"Allo le monde\" void on_connect(struct mosquitto *mosq, void *userdata, int result) { if (result != 0) { fprintf(stderr, \"Erreur: connexion broker MQTT.\\n\"); } } void on_publish(struct mosquitto *mosq, void *userdata, int mid) { printf(\"Message publié.\\n\"); } int main() { struct mosquitto *mosq = NULL; int rc; mosquitto_lib_init(); mosq = mosquitto_new(NULL, true, NULL); if (!mosq) { fprintf(stderr, \"Erreur: création de l'instance mosquitto.\\n\"); return 1; } mosquitto_connect_callback_set(mosq, on_connect); mosquitto_publish_callback_set(mosq, on_publish); rc = mosquitto_connect(mosq, MQTT_BROKER_HOST, MQTT_PORT, 60); if (rc != MOSQ_ERR_SUCCESS) { fprintf(stderr, \"Connexion impossible au broker: %s\\n\", mosquitto_strerror(rc)); return 1; } rc = mosquitto_publish(mosq, NULL, MQTT_TOPIC, strlen(MQTT_MESSAGE), MQTT_MESSAGE, MQTT_QOS, false); if (rc != MOSQ_ERR_SUCCESS) { fprintf(stderr, \"Failed to publish message: %s\\n\", mosquitto_strerror(rc)); } mosquitto_loop_forever(mosq, -1, 1); mosquitto_destroy(mosq); mosquitto_lib_cleanup(); return 0; } Exercice 1 L’agent MQTT mqttbroker.lan diffuse des messages dans 2 rubriques: ex1_tmp et ex1_hum. La première donne une température en Celsius et la 2e un pourcentage d’humidité.\nFaites un programme qui lit les valeurs des 2 rubriques et affiche les données sur une même ligne à chaque 10 secondes, formatées comme suit:\nroot@pi:~# ./ex1 T: 23C | Hum: 45% T: 23C | Hum: 45% T: 22C | Hum: 45% T: 22C | Hum: 45% T: 22C | Hum: 46% Attention, l’agent MQTT n’envoit pas lui-même les données aux 10 secondes…\nSolution /* Les données sont écrites dans des fichiers à mesure qu'elles arrivent. Une fonction lit le contenu de ce fichiers et l'affiche à chaque 10 sec. */ #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cmosquitto.h\u003e #include \u003cpthread.h\u003e #define MQTT_BROKER_HOST \"mqttbroker.lan\" #define MQTT_PORT 1883 #define MQTT_TOP_TMP \"ex1_tmp\" #define MQTT_TOP_HUM \"ex1_hum\" #define FILE_T \"temp.txt\" #define FILE_H \"humi.txt\" #define MQTT_QOS 1 /* Écrit les données 'data'' dans le fichier 'filename' */ int write_data(char* filename,char* data) { FILE *fichier; fichier = fopen(filename, \"w\"); if (fichier == NULL) { printf(\"Erreur lors de l'ouverture du fichier.\\n\"); return 1; } fprintf(fichier,data); fclose(fichier); return 0; } /* Retourne un pointeur sur la chaine de caractères après le délimiteur. extract_data(\"abcd*1234\", '*'') retourne \"1234\" */ char* extract_data(char* data, char delim) { char* substr = strchr(data,delim); if (substr != NULL) { return substr+1; } return NULL; } /* Prend les données dans les deux fichiers et affiche la chaine chaque 10sec */ void print_data() { while(1) { sleep(10); FILE *fptr; fptr = fopen(FILE_T, \"r\"); char temp[3]; fgets(temp,3,fptr); fclose(fptr); fptr = fopen(FILE_H, \"r\"); char humi[3]; fgets(humi,3,fptr); fclose(fptr); fprintf(stdout,\"T: %sC | Hum: %s\\%\\n\",temp,humi); fflush(stdout); } } void on_connect(struct mosquitto *mosq, void *userdata, int result) { if (result == 0) { // S'abonner à 2 rubriques mosquitto_subscribe(mosq, NULL, MQTT_TOP_TMP, MQTT_QOS); mosquitto_subscribe(mosq, NULL, MQTT_TOP_HUM, MQTT_QOS); } else { fprintf(stderr, \"Erreur: connexion broker MQTT.\\n\"); } } void on_message(struct mosquitto *mosq, void *userdata, const struct mosquitto_message *message) { char* data = extract_data((char *)message-\u003epayload,'|'); // message-\u003etopic détermine dans quel fichier on écrit if (strcmp(message-\u003etopic,MQTT_TOP_TMP) == 0) { write_data(FILE_T,data); } else { write_data(FILE_H,data); } } int main() { struct mosquitto *mosq = NULL; int rc; mosquitto_lib_init(); mosq = mosquitto_new(NULL, true, NULL); if (!mosq) { fprintf(stderr, \"Erreur: création de l'instance mosquitto.\\n\"); return 1; } mosquitto_connect_callback_set(mosq, on_connect); mosquitto_message_callback_set(mosq, on_message); rc = mosquitto_connect(mosq, MQTT_BROKER_HOST, MQTT_PORT, 60); if (rc != MOSQ_ERR_SUCCESS) { fprintf(stderr, \"Connexion impossible au broker: %s\\n\", mosquitto_strerror(rc)); return 1; } // Lancer print_data dans un thread pthread_t t_mosq; if (pthread_create(\u0026t_mosq,NULL,print_data,NULL) != 0) { printf(\"Erreur à la création du thread pour publication.\\n\"); return 1; } mosquitto_loop_forever(mosq, -1, 1); mosquitto_destroy(mosq); mosquitto_lib_cleanup(); return 0; } Exercice 2 Quels sont les sous-rubriques de $SYS qui permettent d’obtenir les informations suivantes sur l’agent :\nNombre d’octets de données reçues Nombre total de clients connectés Nombre de messages reçus durant les 15 dernières minutes Le nombre d’abonnements en cours Cherchez la réponse dans la documentation ( https://mosquitto.org/man/mosquitto-8.html ), puis modifiez le programme client mqtt_sub.c pour afficher à la console ces 4 rubriques.\nSolution Ajouter les lignes suivantes dans la fonction on_connect():\nvoid on_connect(struct mosquitto *mosq, void *userdata, int result) { if (result == 0) { mosquitto_subscribe(mosq, NULL, \"$SYS/broker/bytes/received\", MQTT_QOS); mosquitto_subscribe(mosq, NULL, \"$SYS/broker/clients/connected\", MQTT_QOS); mosquitto_subscribe(mosq, NULL, \"$SYS/broker/load/messages/received/15min\", MQTT_QOS); mosquitto_subscribe(mosq, NULL, \"$SYS/broker/subscriptions/count\", MQTT_QOS); } else { fprintf(stderr, \"Erreur: connexion broker MQTT.\\n\"); } } Exercice 3 Créez le fichier /etc/mosquitto/mosquittocl.conf. Celui-ci contiendra 4 paramètres de configuration pour votre client:\nLe nom ou l’adresse IP de l’agent Le nom du topic Le nom d’utilisateur Le mot de passe Chaque élément devra être sur sa propre ligne, par exemple:\n192.168.0.110 appli_mqtt bob abc-123 Modifiez le code du projet 2 pour que vos 2 programmes client utilisent les données dans ce fichier de configuration.\nSolution Ajouter une référence au fichier de configuration:\n#define MQTT_CLIENT_CONFIG \"/root/410-projet2/mosquittocl.conf\" Ensuite, supprimer les variables MQTT_BROKER, MQTT_TOPIC.\nAjouter les globales suivantes:\nchar* mqtt_broker; char* mqtt_topic; char* mqtt_user; char* mqtt_psw; Ajouter la fonction pour lire les variables dans le fichier:\nint get_config(char* filename) { FILE* f; char* ligne = NULL; size_t taille = 0; ssize_t read; f = fopen(filename,\"r\"); if (f == NULL) { return 1; } read = getline(\u0026ligne,\u0026taille,f); mqtt_broker = (char *)malloc((strlen(ligne) + 1) * sizeof(char)); strcpy(mqtt_broker, r_trim(ligne)); read = getline(\u0026ligne,\u0026taille,f); mqtt_topic = (char *)malloc((strlen(ligne) + 1) * sizeof(char)); strcpy(mqtt_topic, r_trim(ligne)); read = getline(\u0026ligne,\u0026taille,f); mqtt_user= (char *)malloc((strlen(ligne) + 1) * sizeof(char)); strcpy(mqtt_user, r_trim(ligne)); read = getline(\u0026ligne,\u0026taille,f); mqtt_psw = (char *)malloc((strlen(ligne) + 1) * sizeof(char)); strcpy(mqtt_psw, r_trim(ligne)); fclose(f); } Ajouter le code suivant dans main():\nif (get_config(MQTT_CLIENT_CONFIG) != 0){ fprintf(stderr, \"Erreur: Lecture du fichier de configuration.\\n\"); return 1; } mosquitto_username_pw_set(mosq,mqtt_user,mqtt_psw);",
    "description": "Pour le cours, SVP utilisez l’agent MQTT disponible sur le réseau interne au nom mqttbroker.lan.\nDans ce cours nous utiliserons Mosquitto. Cette implémentation de MQTT, développée par la fondation Eclipse, fournit des utilitaires de ligne de commande pour envoyer et recevoir des messages (mosquitto_pub et mosquitto_sub), et aussi des librairies permettant d’implémenter des clients MQTT en C/C++.\nAgent MQTT Mosquitto Pour installer le service mosquitto, lancez la commande suivante:\napt update apt install mosquitto Configuration de base Les paramètres de configuration de mosquitto sont définis dans le fichier /etc/mosquitto/mosquitto.conf.",
    "tags": [],
    "title": "Utilisation",
    "uri": "/420-410/mqtt/utilisation/index.html"
  },
  {
    "breadcrumb": "MQTT",
    "content": "Préalables Connectez un senseur de luminosité à votre Pi.\nVous devez faire 2 programmes:\np2_pub: Publie chaque 10 secondes dans la rubrique p2 la valeur de luminosité lue sur le senseur; p2_sub: À partir des données lues sur tous les Pi, affiche le nom du Pi d’où est lue la valeur maximale, et la moyenne de toutes les valeurs. Spécifications: Le message publié doit avoir le format HOTE|VALEUR. HOTE est le hostname du Pi et VALEUR est le pourcentage de luminosité (un nombre entier entre 0 et 100). Les informations doivent s’afficher comme suit, à intervalles réguliers, sur la console lorsque vous exécutez le programme: Max: denis (93) Moy: 60.40 ------------- Max: WuJitsu (56) Moy: 24.60 ------------- Max: Equipe 3 (72) Moy: 34.20 -------------",
    "description": "Préalables Connectez un senseur de luminosité à votre Pi.\nVous devez faire 2 programmes:\np2_pub: Publie chaque 10 secondes dans la rubrique p2 la valeur de luminosité lue sur le senseur; p2_sub: À partir des données lues sur tous les Pi, affiche le nom du Pi d’où est lue la valeur maximale, et la moyenne de toutes les valeurs. Spécifications: Le message publié doit avoir le format HOTE|VALEUR. HOTE est le hostname du Pi et VALEUR est le pourcentage de luminosité (un nombre entier entre 0 et 100). Les informations doivent s’afficher comme suit, à intervalles réguliers, sur la console lorsque vous exécutez le programme: Max: denis (93) Moy: 60.40 ------------- Max: WuJitsu (56) Moy: 24.60 ------------- Max: Equipe 3 (72) Moy: 34.20 -------------",
    "tags": [],
    "title": "Projet 2",
    "uri": "/420-410/mqtt/projet2/index.html"
  },
  {
    "breadcrumb": "Bluetooth",
    "content": "Bluetooth a été inventé pour remplacer les câbles qu’on utilisait pour connecter les appareils et leurs périphériques, comme par exemple les écouteurs, les souris ou les manettes de jeu.\nIl est basé sur une architecture client-serveur, mais permet seulement une communication de 1 à 1 entre deux composantes: les multiples clients d’un même serveur ne peuvent pas utiliser bluetooth pour communiquer entre eux.\nEn plus de la version habituelle du protocole, aussi nommée classique, il existe une version allégée nommée Bluetooth LE (aussi BLE, pour “Bluetooth low energy”). Celle-ci a été conçue expressément pour les objets connectés et se caractérise par les aspects suivants:\nFaible consommation d’énergie Taux de transferts plus bas Mieux adaptée aux transferts de petites quantités de données Même si de nombreuses composantes supportent les deux versions de Bluetooth, les deux sont assez différents pour être considérés comme deux protocoles distincts. Il est donc possible que des composantes supportent l’un mais pas l’autre.\nDans cette section nous allons tester la communication blutooth classique entre un RaspberryPi et un téléphone Android en utilisant la librairie btferret.\nPrérequis Sur le téléphone Android Installer l’application Serial Bluetooth Terminal Play Store Code source Trouver l’adresse MAC de l’interface bluetooth du téléphone Activer bluetooth Sur le Pi Cloner le projet btferret Supprimer le contenu du fichier devices.txt à la racine du projet btferret Le projet contient de nombreux programmes:\nbtlib: la librairie bluetooth et BLE btferret: le programme linux pour utiliser bluetooth bluedot: une application client-serveur pour Android classic_client, classic_server: des applications client-serveur le_client, le_server: des applications client-serveur pour BLE keyboard: permet au Pi de se connecter comme un clavier BT rn4020: programme pour communiquer avec le module RN4020 (BLE) sample: exemple des différents types de connexions supportées par BT Première exécution Pour compiler puis exécuter btferret, lancez les commandes suivantes:\ngcc btferret.c btlib.c -o btferret ./btferret Le programme est un utilitaire en ligne de commande qui utilise la librairie btlib.\nÀ la première exécution du programme, on a le message suivant:\nIt should be added to the devices.txt file as follows: DEVICE=name (e.g. My Pi) TYPE=MESH NODE=choose (e.g. 1) ADDRESS=E4:5F:01:EC:63:4E Donc on ajoute une ligne avec les infos du Pi dans devices.txt (remplacez le nom et l’adresse MAC par vos propres valeurs):\nDEVICE=pi-o TYPE=MESH NODE=1 ADDRESS=E4:5F:01:EC:63:4E Relancez ensuite le programme pour prendre compte des changements.\nVous devriez voir le contenu de devices.txt suivi d’une invite de commandes:\nInitialising... Device data from devices.txt file DEVICE=pi-o TYPE=MESH NODE=1 ADDRESS=E4:5F:01:EC:63:4E h = help \u003e Pour voir les commandes possibles, faites h. Parmi elles, voici celles qui sont utiles lors des premières phases de la communication:\na et b pour chercher différents type de périphériques (BT et BLE) i pour des informations sur les périphériques détectés v pour voir les services disponibles sur un périphérique c pour se connecter sur un serveur BT s pour se mettre en mode serveur Établir une connexion Avant que deux appareils puissent s’échanger des données, quelques étapes sont nécessaires:\nDécouverte des périphériques: l’appareil recherche les clients et serveurs à promximité Appariement (“pairing”): les deux appareils s’échangent des informations qui leur permettront de se reconnaître de manière sécurisée plus tard. Cette étape peut nécessiter une confirmation de l’utilisateur sur les appareils. Connexion: les deux appareils établissent un canal de communication pour une application spécifique (écouteurs, clavier, etc.) La première étape est donc de détecter le téléphone. Cependant lorsqu’on fait a, il est très possible qu’il n’aparaisse pas.\nPour des raisons de sécurité, la plupart des téléphones d’aujourd’hui limitent sévèrement les connexions bluetooth entrantes. C’est pour cette raison qu’il ne sera peut-être pas détecté.\nAjoutez une ligne dans le fichier devices.txt pour l’appareil Android. Attention de bien mettre l’adresse MAC de votre téléphone:\nDEVICE=Pixel TYPE=CLASSIC NODE=2 ADDRESS=74:74:46:CB:2B:56 Après avoir redémarré le programme, vous pourrez faire la commande i pour voir les informations:\nnode btlib version 14 1 Local (pi-o) Mesh transmit off E4:5F:01:EC:63:4E 2 Pixel-6 Classic Not connected 74:74:46:CB:2B:56 Informations sur les services Encore pour des raisons de sécurité, les téléphones n’acceptent pas des connexions bluetooth génériques: ils définissent des protocoles (aussi nommés “profils”) pour des applications spécifiques.\nOn peut voir les services disponibles sur le téléphone avec v:\nConnecting to Pixel-6 to read classic serial services... Unexpected extra data - add time delays Unexpected extra data - add time delays Authentication/PIN fail Trying again with no link key.. Passkey = 524055 Valid for 10 seconds Unexpected extra data - add time delays Unexpected extra data - add time delays Pixel-6 has disconnected Pixel-6 RFCOMM serial channels 2 Headset Gateway UUID = 1112 Headset Audio Gateway 3 Handsfree Gateway UUID = 111F HandsfreeAudioGateway 4 SMS/MMS UUID = 1132 Message Access Server 5 OBEX Phonebook Access Server UUID = 112F Phonebook Access PSE 6 SIM Access UUID = 112D SIM_Access 7 OBEX Object Push UUID = 1105 OBEXObjectPush Dans cet exemple, on retrouve des profils pour les connexions d’écouteurs, l’accès aux contacts ou à la carte SIM, etc. Cependant, le programme btferret n’implémente pas les profils permettant d’utiliser ces services.\nMode serveur On configure le Pi en mode serveur afin que la connexion puisse être initiée par le téléphone en mode client.\nAu menu de démarrage de btferret, faites la commande s. Ensuite il faut choisir le mode “Classique”, l’identifiant du client puis le type de sécurité (0)\n\u003e s 0 = node server 1 = classic server 2 = LE server 3 = mesh server Input server type 0/1/2/3 (x=cancel) ? 1 Input node of client that will connect CLASSIC servers + NODE servers 2 - Pixel-6 0 - Any device Input node (x=cancel) ? 2 Client's security (0,1,3 to pair or connect Android/Windows.. clients) 0 = Use link key, print passkey here, remote may ask to confirm 1 = No link key, print passkey here (forces re-pair if pairing fails) 2 = No keys (connecting client is another mesh Pi) 3 = Use link key, no passkey 4 = Use link key, remote prints passkey, enter it here if asked Client's security requirement (x=cancel) ? 0 Server will listen on channel 1 and any of the following UUIDs Standard serial 2-byte 1101 Standard serial 16-byte Custom serial set via register serial Listening for Pixel-6 to connect (x=cancel) Du côté du téléphone Android, il sera ensuite possible de se connecter avec l’application Serial Bluetooth Terminal pour envoyer des messages au Pi.\nExercice 1 Compiler puis exécutez le programme classic_server.c et envoyez-lui des messages à partir de votre téléphone.\nExercice 2 Modifiez le programme serveur pour qu’il réponde “pong” lorsqu’il reçoit le message “ping” et qu’il se déconnecte pour n’importe quel autre message. Solution #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"btlib.h\" int callback(int node, unsigned char *data, int len); int main() { int security, keyflag; if (init_blue(\"devices.txt\") == 0) return (0); security = 3; keyflag = KEY_ON | PASSKEY_LOCAL; if (security == 1) keyflag = KEY_OFF | PASSKEY_LOCAL; else if (security == 2) keyflag = KEY_OFF | PASSKEY_OFF; else if (security == 3) keyflag = KEY_ON | PASSKEY_OFF; classic_server(ANY_DEVICE, callback, 10, keyflag); close_all(); } int callback(int node, unsigned char *data, int len) { static unsigned char *message = {\"pong\\n\"}; printf(\" %s\", data); if (strcmp(data, \"ping\\r\\n\") == 0) { write_node(node, message, strlen(message)); printf(\"%s\", message); return (SERVER_EXIT); } return (SERVER_CONTINUE); } Exercice 3 Connectez le module LED sur votre Pi. Modifiez ensuite le programme serveur pour que “1” allume la LED et “0” l’éteigne. Solution #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"btlib.h\" #include \u003cpigpio.h\u003e #define LED 26 int callback(int node, unsigned char *data, int len); int main() { int security, keyflag; // Initialiser if (gpioInitialise() \u003c 0) { fprintf(stderr, \"Erreur d'initialisation pigpio\\n\"); return 1; } // Définir en mode output gpioSetMode(LED, PI_OUTPUT); if (init_blue(\"devices.txt\") == 0) return (0); security = 3; keyflag = KEY_ON | PASSKEY_LOCAL; if (security == 1) keyflag = KEY_OFF | PASSKEY_LOCAL; else if (security == 2) keyflag = KEY_OFF | PASSKEY_OFF; else if (security == 3) keyflag = KEY_ON | PASSKEY_OFF; classic_server(ANY_DEVICE, callback, 10, keyflag); close_all(); } int callback(int node, unsigned char *data, int len) { printf(\" %s\", data); switch (data[0]) { case '1': gpioWrite(LED, 1); break; case '0': gpioWrite(LED, 0); break; default: break; } return (SERVER_CONTINUE); } Exercice 4 Avec une autre équipe, adaptez les programmesclassic_client.c et classic_server.c pour faire un programme de chat simple: une fois connecté, le client et le serveur peuvent s’échanger des messages comme suit:\nServeur\nConnected OK Waiting for data from Raspberrypi (x = stop server) hey \u003e salut boum \u003e pouet Raspberrypi has disconnected Client\nConnect OK \u003e hey salut \u003e boum pouet \u003e * Lorsque le client envoit le caractère *, le serveur se déconnecte.\nLa fonction read_node_endchar() (référence) sera utile pour le programme client.\nSolution SERVEUR #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"btlib.h\" #define MAX_SIZE 100 int callback(int node, unsigned char *data, int len); int main() { int security, keyflag; if (init_blue(\"devices.txt\") == 0) return (0); // Essayer 0,1,2,3 si problème security = 3; keyflag = KEY_ON | PASSKEY_LOCAL; if (security == 1) keyflag = KEY_OFF | PASSKEY_LOCAL; else if (security == 2) keyflag = KEY_OFF | PASSKEY_OFF; else if (security == 3) keyflag = KEY_ON | PASSKEY_OFF; classic_server(ANY_DEVICE, callback, 10, keyflag); close_all(); } int callback(int node, unsigned char *data, int len) { char *message; size_t length = 0; printf(\" %s\", data); if (data[0] == '*') { printf(\"Déconnexion\\n\"); return (SERVER_EXIT); } printf(\"\u003e \"); getline(\u0026message, \u0026length, stdin); message[length] = '\\n'; write_node(node, message, strlen(message)); free(message); return (SERVER_CONTINUE); } CLIENT #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"btlib.h\" #define NODE_ID 1 #define MAX_SIZE 100 #define END_CHAR 10 // \\n int main() { int channel, ret; char *message; size_t len = 0; unsigned char buf[MAX_SIZE]; if (init_blue(\"devices.txt\") == 0) return (0); channel = find_channel(NODE_ID, UUID_16, strtohex(\"00001101-0000-1000-8000-00805F9B34FB\", NULL)); connect_node(NODE_ID, CHANNEL_NEW, channel); while (1) { printf(\"\u003e \"); getline(\u0026message, \u0026len, stdin); write_node(NODE_ID, message, strlen(message)); free(message); ret = read_node_endchar(NODE_ID, buf, MAX_SIZE, END_CHAR, EXIT_TIMEOUT, 300000); printf(\" %s\",buf); } disconnect_node(NODE_ID); close_all(); } Exercice 5 Dans cet exercice, un message doit circuler à travers toutes les équipes: chaque équipe reçoit un message d’une autre équipe et doit immédiatement le retransmettre à une 3e équipe. Votre programme doit donc:\nDémarrer en mode serveur Recevoir un message Arrêter le serveur Se connecter sur un autre serveur et envoyer le message.",
    "description": "Bluetooth a été inventé pour remplacer les câbles qu’on utilisait pour connecter les appareils et leurs périphériques, comme par exemple les écouteurs, les souris ou les manettes de jeu.\nIl est basé sur une architecture client-serveur, mais permet seulement une communication de 1 à 1 entre deux composantes: les multiples clients d’un même serveur ne peuvent pas utiliser bluetooth pour communiquer entre eux.\nEn plus de la version habituelle du protocole, aussi nommée classique, il existe une version allégée nommée Bluetooth LE (aussi BLE, pour “Bluetooth low energy”). Celle-ci a été conçue expressément pour les objets connectés et se caractérise par les aspects suivants:",
    "tags": [],
    "title": "Serveur classique",
    "uri": "/420-410/bluetooth/serveurbt/index.html"
  },
  {
    "breadcrumb": "MQTT",
    "content": "Pour sécuriser les communications en MQTT, on utilise les mêmes méthodes que pour n’importe quel autre protocole, c’est-à-dire: l’authentification et le chiffrement.\nCes deux méthodes sont appliquées indépendamment l’une de l’autre: en effet, on peut avoir des communications chiffrées sans authentification, ou au contraire authentifiées mais sans chiffrement. Évidemment, il est recommandé d’utiliser les deux.\nDans cette section, nous allons décrire le fonctionnement de chacune de ces méthodes puis nous expliquerons comment les appliquer aux clients et aux agents MQTT.\nAuthentification C’est dans la configuration de l’agent MQTT que l’authentification doit être activée.\nLorsqu’elle l’est, les clients MQTT devront fournir un nom d’utilisateur et un mot de passe chaque fois qu’ils établissent une connexion auprès de l’agent, donc:\nUn client doit s’authentifier chaque fois qu’il publie sur une rubrique; Un client doit s’authentifier une seule fois lorsqu’il s’abonne à une rubrique. Un des avantages de l’authentification est qu’elle permet d’utiliser des listes de contrôle d’accès pour limiter les rubriques sur lesquelles les clients peuvent publier ou s’abonner.\nPour activer l’authentification sur le serveur, il faut mettre allow_anonymous à false, ou encore commenter allow_anonymous true dans le fichier de configuration. Aussi, il faut définir dans la directive password_file le chemin du fichier qui contient les identifiants et mots de passe des utilisateurs:\n# Fichier /etc/mosquitto/mosquitto.conf #allow_anonymous true password_file /etc/mosquitto/passwd Fichier des utilisateurs Pour ajouter un utilisateur la commande est mosquitto_passwd. La commande doit être suivie du nom du fichier des utilisateurs puis du nom de l’utilisateur que vous souhaitez créer; vous devrez ensuite entrer le mot de passe manuellement:\nroot@broker:~# mosquitto_passwd /etc/mosquitto/users sam Password: Reenter password: Si le fichier n’existe pas, utilisez l’option -c (comme “create”) pour le créer.\nLe fichier contient les hachages de mots de passe:\nroot@broker:~# cat /etc/mosquitto/users sam:$7$101$Fx8sWVNUkHTOL0eY$s66bwEUeQhM5atnmd19DEKDExYnLhVQYaWQNPBWkjGqgEOOABdWdMSasLLOy2HODeF0JLpnwf58cteIPkKe5hg== Malgré cela, il est recommandé que le fichier des utilisateurs soit accessible uniquement à l’utilisateur mosquitto:\nroot@broker:~# ls -l /etc/mosquitto/users -rw------- 1 mosquitto mosquitto 472 Apr 5 18:00 /etc/mosquitto/users Authentification sur la ligne de commande Pour les utilitaires mosquitto_pub et mosquitto_sub, il faut passer les identifiants et mots de passe avec les options -u et -P (respectivement):\nroot@pi:~# mosquitto_sub -h 10.10.22.154 -t \"meteo\" -u sam -P abc-123 Authentification dans un programme Dans un programme en C utilisant libmosquitto-dev, la fonction mosquitto_username_pw_set() permet de spécifier les identifiants de connexion. Elle doit être appelée avant la connexion à l’agent:\nmosquitto_username_pw_set(mosq,\"sam\",\"abc-123\"); Dans l’exemple précédent, l’argument mosq correspond à l’identifiant retourné par la fonction mosquitto_new().\nChiffrement La méthode éprouvée pour assurer la confidentialité des communications à la couche TCP est d’utiliser des certificats avec le protocole TLS (“Transport Layer Security”).\nLes certificats sont échangés chaque fois qu’un client et un serveur souhaitent établir une connexion TCP sur lequelle tous les messages seront chiffrés. Ces certificats contiennent des informations permettant de générer une clé de session, qui est une clé symétrique utilisée pour chiffrer et déchiffrer les messages. Elle est détruite dès que la connexion entre les deux hôtes est fermée.\nMais avant d’envoyer des informations confidentielles chiffrées à un hôte sur le réseau, il faut être certain que cet hôte est digne de confiance. Les certificats servent donc aussi à garantir que l’hôte qui le présente est approuvé par un tiers, et donc qu’on peut lui faire confiance.\nOn nomme ces tiers les autorités de certification (ou CA pour “certification authority”).\nFonctionnement des certificats numériques Imaginez 2 hôtes: A et B. Les deux veulent s’envoyer des messages chiffrés, mais aussi ils veulent être certains de l’identité de l’autre. Il ont donc besoin qu’une entité en qui les deux ont confiance, CA, atteste que A et B sont bien qui ils prétendent.\nChacun des 3 va donc générer une paire de clés (une clé publique et une clé privée). CA distribue aux 2 autres sa clé publique et cache sa clé privée.\nCA crée son propre certificat et utilise sa clé privée pour le signer. A et B utilisent la clé publique de CA pour vérifier cette signature: si la clé publique qu’ils ont permet de déchiffrer correctement cette signature, alors cela signifie qu’elle a été créée avec la clé privée de CA, et comme CA a bien caché sa clé privée, on a l’assurance que le certificat a bien été signé par CA. À cette étape, A et B sont certains de l’authenticité du certificat de CA.\nEnsuite, A demande à CA d’attester son identité. Pour ce faire, il crée son propre certificat, y ajoute sa clé publique et demande à CA de le signer. CA utilise sa propre clé privée pour signer le certificat de A. A est maintenant en possession d’un certificat qui contient:\nSa propre clé publique La signature de CA Le certificat de CA Lorsque A transmettra son certificat à B, B utilisera le clé publique de CA pour vérifier que la signature est valide. La confiance que B a en CA lui permet de croire que A est authentique, et qu’il peut utiliser la clé publique de A en toute confiance pour chiffrer des messages.\nPar la suite, lorsque B voudra chiffrer les messages qu’il envoit à A, il génèrera une clé de session, la chiffrera avec la clé publique de A et lui enverra. A déchiffrera cette clé de session et les deux pourront l’utiliser pour s’envoyer des messages chiffrés.\nCréation et signature de certificats L’outil openssl permet entre autres de créer des paires de clés, des signatures numériques et des demandes de de certificat. Nous verrons ici comment l’utiliser pour effectuer chacune des opérations requises pour déployer des certificats dans une infrastructure MQTT.\nCertificat de la CA On veut créer le certificat d’une CA qui sera ensuite utilisé pour valider d’autres certificats. La commande est la suivante:\nopenssl req -new -x509 -days 365 -extensions v3_ca -keyout ca.key -out ca.crt Les options de la commande sont les suivantes:\nreq: On veut créer une demande -new: Le fichier à créer est pour un nouveau certificat -x509: On veut que le fichier créé soit le certificat lui-même -days: La dureée de validité du certificat -extensions: Ajouter les sections propres aux CA dans le certificat -keyout: Le nom de la clé privée qu’on veut générer en même temps -out: Le nom du fichier généré Suite à cette commande vous devrez saisir un mot de passe (“PEM pass phrase”) utilisé pour protéger la clé privée de la CA. Ensuite on vous demande d’entrer diverses informations servant à identifier la CA.\nCertificat de l’hôte Les étapes sont les suivantes:\nCréer la clé privée de l’hôte Créer la demande de certificat de l’hôte Signer la demande de l’hôte avec le certificat de la CA Déployer le certificat de l’hôte Pour créer la clé privée:\nopenssl genrsa -out hote.key 2048 Cette clé privée permet de générer la clé publique qui sera incluse dans le certificat de l’hôte.\nLa commande pour créer la demande de certificat de l’hôte (hote.csr):\nopenssl req -out hote.csr -key hote.key -new Les options de la commande sont les suivantes:\nreq: On veut créer une demande -new: Le fichier à créer est une nouvelle demande -key: La clé privée utilisée pour générer la clé publique à joindre au certificat -out: Le nom du fichier généré ATTENTION: Lorsque vous saisirez les informations à inclure dans le certificat de l’agent, assurez-vous que Common Name a comme valeur le nom DNS utilisé pour vous connecter à l’agent (le nom utilisé après l’option -h dans la commande mosquitto_pub).\nLa commande pour signer la demande de l’hôte:\nopenssl x509 -req -in hote.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out hote.crt -days 365 Les options de la commande sont les suivantes:\nx509: On veut créer un certificat -req: On veut créer le certificat à partir d’une demande -in: Le fichier de la demande -CA: Le certificat de la CA -CAkey: La clé privée de la CA -CAcreateserial: Créer un numéro de série pour le certificat (stocké dans un fichier ayant l’extension .srl) -out: Le nom du fichier du certificat créé -days: La dureée de validité du certificat Configuration de l’agent Lorsque l’hôte est un “broker” MQTT, il faut que le service mosquitto puisse localiser le certificat de la CA, son propre certificat et sa clé privée. Aussi, par convention on recommande que le port utilisé soit 8883 si MQTT utilise TLS. On doit donc avoir les lignes suivantes dans le fichier de configuration /etc/mosquitto/mosquitto.conf:\nlistener 8883 0.0.0.0 cafile /etc/mosquitto/ca_certificates/ca.crt certfile /etc/mosquitto/certs/hote.crt keyfile /etc/mosquitto/certs/hote.key require_certificate true Configuration d’un client Le certificat de la CA, du client et sa clé privée doivent également être spécifiées au moment de la connexion à l’agent.\nLes options pour mosquitto_pub et mosquitto_sub sont les suivantes:\n-cafile: le fichier du certificat de la CA -cert: le certificat du client -key: la clé du client -p: le port Par exemple:\nmosquitto_pub -h 10.10.21.13 -t \"meteo/serre\" -m \"17.5\" -p 8883 -cafile ca.crt -cert client.crt -key client.key Dans un programme en C utilisant la librairie libmosquitto-dev, il faut appeler la fonction mosquitto_tls_set() avant la connexion à l’agent. Un exemple:\nchar* ca = \"/etc/mosquitto/ca.crt\"; char* cert = \"/etc/mosquitto/client.crt\"; char* key = \"/etc/mosquitto/client.key\"; mosquitto_tls_set(mosq, ca, NULL, cert, key, NULL); Exercice 1 Créez un agent MQTT sur votre hôte sur le réseau du département, et configurez-le pour que les clients doivent s’authentifier (prenez un nom et un mot de passe de votre choix). Ensuite, testez avec les commandes mosquitto_pub et mosquitto_sub.\nExercice 2 Créez un certificat pour une nouvelle autorité de certification. Les valeurs doivent être les suivantes:\nPays: CA Province: Qc Ville: Montreal Organisation: Informatique Marie-Victorin Exercice 3 Créez 2 certificats: 1 pour le client et 1 pour l’agent; attention au champ “Common Name” pour celui de l’agent. Signez chacun avec le certificat de la CA que vous venez de créer.\nEnsuite déployez ces certificats sur vos clients et votre agent.\nComment pouvez-vous prouver que la communication est bien chiffrée?",
    "description": "Pour sécuriser les communications en MQTT, on utilise les mêmes méthodes que pour n’importe quel autre protocole, c’est-à-dire: l’authentification et le chiffrement.\nCes deux méthodes sont appliquées indépendamment l’une de l’autre: en effet, on peut avoir des communications chiffrées sans authentification, ou au contraire authentifiées mais sans chiffrement. Évidemment, il est recommandé d’utiliser les deux.\nDans cette section, nous allons décrire le fonctionnement de chacune de ces méthodes puis nous expliquerons comment les appliquer aux clients et aux agents MQTT.",
    "tags": [],
    "title": "Sécurité",
    "uri": "/420-410/mqtt/securite/index.html"
  },
  {
    "breadcrumb": "Threads",
    "content": "Dans les applications connectées, il est fréquent qu’un même programme doive gérer plusieurs processus simultanément. Cela peut poser des problèmes lorsqu’une tâche monopolise le processeur et que pendant ce temps, d’autres processus attendent leur tour.\nDans un programme ordinaire, les instructions sont exécutées en séquence:\nlong double pi; pi = calculerPiALaMillioniemeDecimale() printf(\"SVP Patientez\"); Dans cet exemple, le message “SVP Patientez” est assez inutile car l’instruction printf() ne s’exécutera pas tant que la fonction de la ligne précédente ne sera pas terminée.\nPrenons un programme simple qui fait clignoter indéfiniment un module LED toutes les 250ms:\n#include \u003cstdio.h\u003e #include \u003cpigpio.h\u003e #include \u003cunistd.h\u003e #define LED 17 int main() { // Initialiser if (gpioInitialise() \u003c 0) { fprintf(stderr, \"Erreur d'initialisation pigpio\\n\"); return 1; } // Définir en mode output gpioSetMode(LED, PI_OUTPUT); while (1) { // Allumer 1 s gpioWrite(LED, 1); usleep(250000); // Éteindre 1 s gpioWrite(LED, 0); usleep(250000); } // Libérer les ressources gpioTerminate(); return 0; } Comment peut-on modifier ce programme pour faire clignoter 2 modules LED, 1 chaque 250ms et l’autre chaque 500ms?\n#include \u003cstdio.h\u003e #include \u003cpigpio.h\u003e #include \u003cunistd.h\u003e int main() { // Faire clignoter LED 1 chaque 250ms et LED 2 chaque 500ms int LED1 = 17; int LED2 = 24; // Initialiser if (gpioInitialise() \u003c 0) { fprintf(stderr, \"Erreur d'initialisation pigpio\\n\"); return 1; } // Définir en mode output gpioSetMode(LED1, PI_OUTPUT); gpioSetMode(LED2, PI_OUTPUT); while (1) { gpioWrite(LED1, 1); gpioWrite(LED2, 1); usleep(250000); gpioWrite(LED1, 0); usleep(250000); gpioWrite(LED1, 1); gpioWrite(LED2, 0); usleep(250000); gpioWrite(LED1, 0); usleep(250000); } // Libérer les ressources gpioTerminate(); return 0; } On voit immédiatement que cette solution n’est pas idéale car la structure de notre programme dépend des données. Si en effet on veut changer les durées, par exemple 1 LED qui clignote chaque 300ms et l’autre chaque 700ms, il faudra revoir tout ce que contient la boucle while.\nIntuitivement on voit qu’il serait préférable d’avoir deux boucles et que chacune définit sa propre durée. Le programme suivant est mieux construit:\n#include \u003cstdio.h\u003e #include \u003cpigpio.h\u003e #include \u003cunistd.h\u003e #define LED1 17 #define LED2 24 void clignoter1() { for (;;) { gpioWrite(LED1, 1); usleep(250000); gpioWrite(LED1, 0); usleep(250000); } } void clignoter2() { for (;;) { gpioWrite(LED2, 1); usleep(500000); gpioWrite(LED2, 0); usleep(500000); } } int main() { // Faire clignoter LED 1 chaque 250ms et LED 2 chaque 500ms // Initialiser if (gpioInitialise() \u003c 0) { fprintf(stderr, \"Erreur d'initialisation pigpio\\n\"); return 1; } // Définir en mode output gpioSetMode(LED1, PI_OUTPUT); gpioSetMode(LED2, PI_OUTPUT); clignoter1(); clignoter2(); // Libérer les ressources gpioTerminate(); return 0; } Chacune des deux boucles est définie dans sa propre fonction, et même si il y a plusieurs répétitions, le programme est mieux structuré. Par contre il ne donne pas le résultat escompté car les deux fonctions vont s’éxécuter une après l’autre.\nThreads En programmation, il est possible de créer des nouveaux processus plus ou moins indépendants du flot normal d’exécution du programme principal. On nomme ces processus “threads”.\nLorsqu’on crée un thread, on lui associe une fonction. Cette fonction sera exécutée dans son propre processus et ainsi ne bloquera pas le processus principal.\nDans l’exemple suivant, on utilise la fonction pthread_create() pour lancer les fonctions “clignoter” dans leurs propres processus:\n#include \u003cstdio.h\u003e #include \u003cpigpio.h\u003e #include \u003cunistd.h\u003e #include \u003cpthread.h\u003e #define LED1 17 #define LED2 24 void *clignoter1() { for (;;) { gpioWrite(LED1, 1); usleep(250000); gpioWrite(LED1, 0); usleep(250000); } } void *clignoter2() { for (;;) { gpioWrite(LED2, 1); usleep(500000); gpioWrite(LED2, 0); usleep(500000); } } int main() { // Faire clignoter LED 1 chaque 250ms et LED 2 chaque 500ms // Initialiser if (gpioInitialise() \u003c 0) { fprintf(stderr, \"Erreur d'initialisation pigpio\\n\"); return 1; } // Définir en mode output gpioSetMode(LED1, PI_OUTPUT); gpioSetMode(LED2, PI_OUTPUT); // Créer les threads pthread_t t_led1,t_led2; if (pthread_create(\u0026t_led1,NULL,clignoter1,NULL) != 0) { printf(\"Erreur à la création du thread pour LED 1.\\n\"); return 1; } if (pthread_create(\u0026t_led2,NULL,clignoter2,NULL) != 0) { printf(\"Erreur à la création du thread pour LED 2.\\n\"); return 1; } // Attendre la fin de l'exécution de chaque thread pthread_join(t_led1, NULL); printf(\"Fin du thread 1.\\n\"); pthread_join(t_led2, NULL); printf(\"Fin du thread 2.\\n\"); // Libérer les ressources gpioTerminate(); return 0; } Les modifications apportées au code:\nAjouté #include \u003cpthread.h\u003e Les fonctions sont déclarées comme des pointeurs Des variables de type pthread_t réfèrent aux threads créés La fonction pthread_create() crée les threads La fonction pthread_join() attend que les threads se terminent ATTENTION: Au moment de la compilation, il faut ajouter l’option -lpthread à la commande gcc.\npthread_create() Sert à créer un thread, le mettre dans une variable et l’associer à une fonction donnée. Dans le programme cette fonction a 4 paramètres:\n\u0026t_led1 : La référence au thread créé NULL : Les attributs qu’on veut lui donner (par exemple sa priorité, la taille de la mémoire allouée, etc.). Si NULL, le thread aura des valeurs par défaut. clignoter : Le nom de la fonction que le processus doit appeler. Attention, il n’y a pas les parenthèses: on donne le nom seulement. NULL : Un pointeur vers les arguments de la fonction s’il y en a. pthread_join() Attend la fin de l’exécution du processus et revient au programme principal. Dans l’exemple, comme on a des boucles infinies on n’y arrivera jamais.\nt_led1 : La référence au thread créé NULL : Une variable qui contiendra la valeur retournée par la fonction. Pause pour le prof Modifier les fonctions pour que les LED clignotent 10 fois seulement. Comment changer la boucle FOR des fonctions pour que le thread 2 termine avant le premier? Passage de paramètres On aurait un meilleur programme si on avait une seule fonction clignoter() à laquelle on passerait toutes les variables:\n// 'ms' est le nombre de millisecondes // 'gpio' est le numéro de broche GPIO void *clignoter(int ms, int gpio) { for (int i=0;i\u003c15;i++) { gpioWrite(gpio, 1); usleep(ms*000); gpioWrite(gpio, 0); usleep(ms*000); } } Mais la fonction passée à pthread_create() ne peut pas avoir plusieurs arguments: elle n’a droit qu’à un seul. Celui-ci peut cependant être un pointeur, donc on peut passer à la fonction un tableau (ou une struct) qui contient autant d’éléments qu’on veut, simplement en passant un pointeur sur ce tableau.\nOn réécrira donc la fonction pour que la variable passée soit un tableau de deux éléments; le premier est le nombre de millisecondes, et le deuxième est le numéro de GPIO:\nvoid *clignoter(int *args) { for (int i=0;i\u003c15;i++) { gpioWrite(args[1], 1); usleep(args[0]*000); gpioWrite(args[1], 0); usleep(args[0]*000); } } Il faut aussi modifier la partie du programme où on crée les threads:\npthread_t t_led1,t_led2; int arg1[] = {250,LED1}; int arg2[] = {500,LED2}; if (pthread_create(\u0026t_led1,NULL,clignoter,\u0026arg1) != 0) { printf(\"Erreur à la création du thread pour LED 1.\\n\"); return 1; } if (pthread_create(\u0026t_led2,NULL,clignoter,\u0026arg2) != 0) { printf(\"Erreur à la création du thread pour LED 2.\\n\"); return 1; } Si on compile ce programme on aura une erreur. Pourquoi?\nLa raison est la suivante: afin que la fonction passée à pthread_create() ne soit pas limitée dans les types d’arguments qu’elle peut avoir, le 4e paramètre (\u0026arg1 et \u0026arg2 dans l’exemple) sera passé à la fonction comme un pointeur de type void *. Puisque dans notre cas elle est définie avec un argument int *, on a une erreur.\nLa version qui fonctionne:\nvoid *clignoter(void *args) { int *valeurs = (int *)args; int ms = valeurs[0]; int gpio = valeurs[1]; for (int i=0;i\u003c10;i++) { gpioWrite(gpio, 1); usleep(ms*1000); gpioWrite(gpio, 0); usleep(ms*1000); } } On crée un tableau d’entiers, par exemple arg1[], mais ce tableau “perd” en quelque sorte son type lorsqu’il est passé à la fonction pthread_create(). Il est ensuite passé à clignoter() comme un pointeur void, et on lui redonne le type int * pour accéder aux valeurs qu’il contient.\npthread_create() travaille uniquement avec des adresses: celles de la fonction qu’elle doit appeler (c’est pourquoi *clignoter() est déclarée avec *) et celle d’un pointeur void qui indique où se trouvent les arguments à passer à cette fonction. C’est à nous de s’assurer qu’on redonne ensuite le bon type à ce pointeur: si un pointeur a un type void, le compilateur ne sait pas quelle taille la variable occupe en mémoire et donc est incapable de lire sa valeur, de se déplacer à la prochaine valeur, etc.\nExercice 1 Pour l’instant dans notre fonction les LED clignotent 10 fois. Modifier le programme pour que le nombre de clignotements soit le 3e argument passé à la fonction.\nExercice 2 Changez la fonction pour que les LED clignotent toujours 10 fois à 100 ms d’intervalle, avec ces valeurs codées directement dans la fonction. La seule chose qu’il faut passer à clignoter() est donc un int qui désigne le GPIO. Refaites le programme pour que les variables arg1 et arg2 soient des nombres entiers.\nExercice 3 On se base sur l’exercice du chapitre précédent:\n#include \u003cstdio.h\u003e #include \u003cpthread.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003cpigpio.h\u003e #define BUFFER_SIZE 10 #define LED_PIN 17 #define PORT 8888 // Modifier cette fonction pour qu'elle puisse être passée à pthread_create() void clignoter(int gpio) { for (;;) { gpioWrite(gpio, 1); usleep(100000); gpioWrite(gpio, 0); usleep(100000); } } int main() { int socket_local; struct sockaddr_in adr_local, adr_dist; char buffer[BUFFER_SIZE]; // Créer le socket et initialiser l'adresse socket_local = socket(AF_INET, SOCK_DGRAM, 0); memset(\u0026adr_local, 0, sizeof(adr_local)); adr_local.sin_family = AF_INET; adr_local.sin_addr.s_addr = INADDR_ANY; adr_local.sin_port = htons(PORT); // Associer le socket à l'adresse de l'interface bind(socket_local, (const struct sockaddr *)\u0026adr_local, sizeof(adr_local)); //Preparation de pigpio // Initialiser if (gpioInitialise() \u003c 0) { fprintf(stderr, \"Failed to initialize pigpio\\n\"); return 1; } // Définir en mode output gpioSetMode(LED_PIN, PI_OUTPUT); // Réception des messages char input[BUFFER_SIZE]; while (1) { int len,n; len = sizeof(adr_dist); // Stocker le message reçu dans n n = recvfrom(socket_local, (char *)buffer, BUFFER_SIZE, MSG_WAITALL, (struct sockaddr *)\u0026adr_dist, \u0026len); buffer[n] = '\\0'; // Voir quel mot a été reçu if (strcmp(buffer, \"allume\\n\") == 0) { gpioWrite(LED_PIN, 1); } else if(strcmp(buffer,\"ferme\\n\") == 0){ gpioWrite(LED_PIN, 0); } else if(strcmp(buffer,\"exit\\n\") == 0){ gpioWrite(LED_PIN, 0); gpioTerminate(); break; } else if(strcmp(buffer,\"flash\\n\") == 0){ // Créer ici le thread qui lance la fonction clignoter } } return 0; } Ajoutez à ce programme une commande “flash” qui aura pour effet de faire clignoter la LED en créant un thread.",
    "description": "Dans les applications connectées, il est fréquent qu’un même programme doive gérer plusieurs processus simultanément. Cela peut poser des problèmes lorsqu’une tâche monopolise le processeur et que pendant ce temps, d’autres processus attendent leur tour.\nDans un programme ordinaire, les instructions sont exécutées en séquence:\nlong double pi; pi = calculerPiALaMillioniemeDecimale() printf(\"SVP Patientez\"); Dans cet exemple, le message “SVP Patientez” est assez inutile car l’instruction printf() ne s’exécutera pas tant que la fonction de la ligne précédente ne sera pas terminée.",
    "tags": [],
    "title": "Processus en parallèle",
    "uri": "/420-410/threads/parallel/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-410/categories/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-410/tags/index.html"
  }
]
